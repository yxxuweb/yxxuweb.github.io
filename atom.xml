<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yxxu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-27T13:23:43.062Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yxxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise深入理解</title>
    <link href="http://yoursite.com/2018/05/06/Promise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/06/Promise深入理解/</id>
    <published>2018-05-05T16:48:57.000Z</published>
    <updated>2019-11-27T13:23:43.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是<strong>Promise</strong></h2><p><strong>Promise</strong>的核心理念是一个异步操作的结果，<strong>Promise</strong>包含两部分</p><ul><li><code>[[PromiseStates]]</code></li><li><code>[[PromiseValue]]</code></li></ul><p><strong>Promise</strong>状态三种可能：</p><ul><li><code>pending</code>: 悬而未决</li><li><code>resolved</code>: 决定</li><li><code>rejected</code>: 拒绝</li></ul><a id="more"></a><h2 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Called first ?'</span>);</span><br></pre></td></tr></table></figure><p><strong>Promise</strong>的<code>then()</code>具有异步性，当执行到<code>.then()</code>部分，这部分会自动进入到<strong>Promise</strong>的异步事件队列，不会阻塞同步代码的执行，所以<code>Called first?</code>先输出。</p><blockquote><p>输出结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Called first ?</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h2 id="立即执行性"><a href="#立即执行性" class="headerlink" title="立即执行性"></a>立即执行性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Create a promise'</span>);</span><br><span class="line">  resolve(<span class="string">'success'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'After new Promise'</span>);</span><br></pre></td></tr></table></figure><p>从<strong>Promise</strong>的<strong>异步性</strong>，我们可以推断出，<code>After new Promise</code>，会先于<code>then()</code>方法中的输出。同时<strong>Promise</strong>的<strong>立即执行性</strong>，定义了<code>promise</code>定义的同时就会立即执行，并不依赖于<code>then()</code>的调用。而且与函数明显不同，函数需要主动调用才会执行。</p><blockquote><p>输出结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Create a promise</span><br><span class="line">After new Promise</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h2 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2-setTimeout:'</span>, p2);</span><br><span class="line">&#125;, <span class="number">501</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p3-setTimeout:'</span>, p3);</span><br><span class="line">&#125;, <span class="number">501</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1-then:'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2-then:'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p3.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p3-catch'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当<strong>Promise</strong>创建完成时，处于 <em>pending</em> 状态；<br>当<strong>Promise</strong>执行了<code>resolve</code>方法，<strong>Promise</strong>对象的状态会变成 <em>resolved</em> 状态；<br>当<strong>Promise</strong>执行了<code>reject</code>方法，<strong>Promise</strong>对象的状态会变成 <em>rejected</em> 状态；</p><blockquote><p>先输出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1-then: 1</span><br></pre></td></tr></table></figure><p>500ms之后，<code>p2</code>和<code>p3</code>的<strong>Promise</strong>状态被执行，<code>then</code>被触发，输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2-then: 2</span><br><span class="line">p3-catch 3</span><br></pre></td></tr></table></figure></p><blockquote><p>最后会输出:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2-setTimeout: <span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">2</span>&#125;</span><br><span class="line">p3-setTimeout: <span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"rejected"</span>, [[PromiseValue]]: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="状态不可逆性"><a href="#状态不可逆性" class="headerlink" title="状态不可逆性"></a>状态不可逆性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'p1 success 1'</span>);</span><br><span class="line">  resolve(<span class="string">'p1 success 2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'p2 success'</span>);</span><br><span class="line">  reject(<span class="string">'p2 reject'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Promise</strong>一旦变成<code>resolved</code>或是<code>rejected</code>，这个状态就不能再次变化，这就是<strong>Promise</strong>的不可逆性。</p><blockquote><p>输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 success 1</span><br><span class="line">p2 success</span><br></pre></td></tr></table></figure><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">(resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Jquery</strong>对象链式调用是执行<code>jquery</code>方法之后，会继续返回<code>jquery</code>对象；类似这个原理，<strong>Promise</strong>对象的<code>then</code>方法会返回一个新的<code>Promise对象</code>，这样就可以继续调用<code>then</code>方法。同样<code>then</code>方法中的两个参数还是<code>fulfilled</code>对象和<code>rejected</code>对象。</p><p>当<code>return</code>一个值或者<code>Promise.resolve()</code>时，状态为 <em>resolved</em><br>当<code>throw</code>一个异常或者<code>return</code> <code>Promise.reject()</code>,状态为 <em>rejected</em></p><p><strong>注</strong>: 当<code>then()</code>方法中没有<code>return</code>时，会默认返回<code>undefined</code>，状态为 <em>resolved</em></p><blockquote><p>输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">undefined</span><br><span class="line">resolve</span><br><span class="line">reject: reject</span><br></pre></td></tr></table></figure><h2 id="Promise中的异常处理"><a href="#Promise中的异常处理" class="headerlink" title="Promise中的异常处理"></a>Promise中的异常处理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span>, err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span>, value);</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span>, err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span>, err);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Promise</strong>中的异常会交给<code>then</code>方法中的第二个回调函数处理，一旦处理完成，会继续返回一个<code>Promise</code>对象给后续<code>then</code>方法。</p><p>可以看到输出是<code>p1</code>和<code>p2</code>交替输出的，这个并不一定是交替输出，取决于执行情况，也可能是<code>p2</code>先输出。</p><blockquote><p>输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 then err:  ReferenceError: foo is not defined</span><br><span class="line">p2 then value:  2</span><br><span class="line">p1 then then value:  undefined</span><br><span class="line">p2 then then err:  ReferenceError: foo is not defined</span><br><span class="line">p2 then then then value:  1</span><br></pre></td></tr></table></figure><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p><code>Promise.resolve()</code>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(value);</span><br></pre></td></tr></table></figure><ul><li><code>value</code>: 用来解析待返回<code>promise</code>对象的参数，既可以是一个<code>promise</code>对象，也可以是一个<code>thenable</code>（即带有<code>then</code>方法）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(p1);</span></span><br><span class="line"><span class="comment">// console.log(p2);</span></span><br><span class="line"><span class="comment">// console.log(p3);</span></span><br><span class="line"><span class="comment">// console.log(p4);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4 = '</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 = '</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1 = '</span>, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>p1</code>: 接收了一个普通值<code>1</code>，所以会返回一个<code>resolved</code>状态的<strong>Promise</strong>对象，并且值为<code>1</code>。<br><code>p2</code>: 接收了一个promise对象<code>p1</code>，会直接返回这个promise对象。<br><code>p3</code>和<code>p4</code>: 通过<code>new</code>方式创建了一个新的promise对象。</p><p>所以，<code>p1 === p2</code>,<code>p3</code>和<code>p4</code>都是创建的新对象，所以自身和其他三个对象都不相等。</p><blockquote><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p></blockquote><p>但是后三个输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2 &#x3D; 1</span><br><span class="line">p1 &#x3D; 1</span><br><span class="line">p4 &#x3D; 1</span><br></pre></td></tr></table></figure><p>很有意思的是，明明是<code>p4</code>先执行的<code>then</code>方法，但是却是后输出的。</p><p>在定义完4个promise对象时，状态分别为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"pending"</span>, [[PromiseValue]]: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><br>很明显，<code>p4</code>是<code>pending</code>状态，与其他三个不同，因为<code>p4</code>的<code>resolve</code>中接收的参数是一个promise对象<code>p1</code>，<code>resolve</code>会对<code>p1</code>进行“拆箱”操作，这个过程是异步的。</p><p><strong>注</strong>：把基本数据类型转换为对应的引用类型的操作称为装箱，把引用类型转换为基本的数据类型称为拆箱。</p><h2 id="resolve-amp-reject-的区别"><a href="#resolve-amp-reject-的区别" class="headerlink" title="resolve() &amp; reject() 的区别"></a>resolve() &amp; reject() 的区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1-resolve:'</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1-reject:'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2-resolve:'</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2-reject:'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p3.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p3-resolve:'</span>, value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p3-reject:'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>resolve</code>方法和<code>reject</code>方法除了在状态上有区别，处理方式上也有区别，<code>resolve</code>方法上面提到了会对<strong>promise对象</strong>“拆箱”，但是<code>reject</code>方法不会。</p><p><code>p3</code>没有“拆箱”操作，所以会最先输出，直接调用<code>reject</code>方法，输出<code>Promise.resolve(&#39;resolve&#39;)</code>对象<br><code>p1</code>会“拆箱”得到<code>Promise.resolve(&#39;resolve&#39;)</code>这个<strong>promise对象</strong>的状态和值，调用<code>resolve</code>方法。<br><code>p2</code>会“拆箱”得到<code>Promise.reject(&#39;reject&#39;)</code>这个<strong>promise对象</strong>的状态和值，因为得到的状态是<code>rejected</code>，所以会调用<code>reject</code>方法。</p><blockquote><p>输出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p3-reject: <span class="built_in">Promise</span> &#123;[[PromiseStatus]]: <span class="string">"resolved"</span>, [[PromiseValue]]: <span class="string">"resolve"</span>&#125;</span><br><span class="line">p1-resolve: resolve</span><br><span class="line">p2-reject: reject</span><br></pre></td></tr></table></figure><h2 id="all-amp-race-amp-then-区别"><a href="#all-amp-race-amp-then-区别" class="headerlink" title="all() &amp; race() &amp; then() 区别"></a>all() &amp; race() &amp; then() 区别</h2><p><code>Promise.all()</code>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(iterable);</span><br></pre></td></tr></table></figure><p><code>Promise.race()</code>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race(iterable)</span><br></pre></td></tr></table></figure><ul><li><code>iterable</code>: 可迭代对象，例如一个数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerPromisefy = <span class="function">(<span class="params">delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(delay);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerPromisefyReject = <span class="function">(<span class="params">delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(delay);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'Promise all'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  timerPromisefy(<span class="number">1</span>),</span><br><span class="line">  timerPromisefy(<span class="number">7</span>),</span><br><span class="line">  timerPromisefy(<span class="number">10</span>),</span><br><span class="line">  timerPromisefy(<span class="number">9</span>)</span><br><span class="line">]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'Promise all'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'Promise then'</span>);</span><br><span class="line">timerPromisefy(<span class="number">1</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> timerPromisefy(<span class="number">7</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> timerPromisefy(<span class="number">10</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> timerPromisefy(<span class="number">9</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'Promise then'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'Promise race'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  timerPromisefy(<span class="number">1</span>),</span><br><span class="line">  timerPromisefy(<span class="number">7</span>),</span><br><span class="line">  timerPromisefy(<span class="number">10</span>),</span><br><span class="line">  timerPromisefy(<span class="number">9</span>)</span><br><span class="line">]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'Promise race'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise.all()</code>方法返回一个<code>Promise</code>，当<code>iterable</code>参数中的 <em>promise</em> 并行执行，当所有 <em>promise</em> 都已经 <em>resolve</em> 了，返回 <em>resolved</em> 状态。当传递的 <em>promise</em> 包含一个 <em>reject</em> ,则返回 <em>rejected</em> 状态。<br>如果<code>Promise.all()</code>返回 <em>resolved</em> , 那么执行时间取决于执行最最慢的那个 <em>promise</em>；如果<code>Promise.all()</code>返回 <em>rejected</em> , 执行时间取决于第一个返回 <em>rejected</em> 的执行时间。</p><p><code>Promise.race()</code>方法返回一个<code>Promise</code>，当<code>iterable</code>参数中只要有一个 <em>promise</em> 状态被判定了，那么就返回该状态。<br>所以<code>Promise.race()</code>的执行时间取决于执行最快的那个 <em>promise</em>。</p><p><code>Promise.then()</code>方法的执行时间，是每个链式调用总时间之和。</p><blockquote><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise race: 2.3232421875ms</span><br><span class="line">Promise all: 3.675048828125ms</span><br><span class="line">Promise then: 31.32373046875ms</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Promise&quot;&gt;&lt;a href=&quot;#什么是Promise&quot; class=&quot;headerlink&quot; title=&quot;什么是Promise&quot;&gt;&lt;/a&gt;什么是&lt;strong&gt;Promise&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;的核心理念是一个异步操作的结果，&lt;strong&gt;Promise&lt;/strong&gt;包含两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[[PromiseStates]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[PromiseValue]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;状态三种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pending&lt;/code&gt;: 悬而未决&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolved&lt;/code&gt;: 决定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rejected&lt;/code&gt;: 拒绝&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>微信浏览器Bug</title>
    <link href="http://yoursite.com/2018/05/06/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8Bug/"/>
    <id>http://yoursite.com/2018/05/06/微信浏览器Bug/</id>
    <published>2018-05-05T16:48:57.000Z</published>
    <updated>2019-11-27T08:11:17.996Z</updated>
    
    <content type="html"><![CDATA[<p>不是一个笑话，微信浏览器真的有Bug。</p><p>一个我觉得不应该出Bug的地方，它居然有<strong>Bug</strong>，真的很坑。</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在微信浏览器中做上传文件的功能，发现iOS微信浏览器正常工作，但是Android微信浏览器<code>input[file]</code>不能触发<code>change</code>事件。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>出于“自省”，我觉得是我代码写的有问题，我是使用<strong>Vue2</strong>调用的<code>change</code>事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;*&#x2F;*&quot; name&#x3D;&quot;file&quot; @change&#x3D;&quot;fileChange()&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>第一反应就是，微信内置浏览器不支持<strong>Vue2</strong>的<code>@change</code>事件。</p><p>然后我就通过原生JS的写法监听<code>change</code>事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByName(&#39;file&#39;)[0].addEventListener(&#39;change&#39;, fileChange);</span><br></pre></td></tr></table></figure><p>这样修改之后还是不能触发<code>change</code>事件，又改写了另一种原生写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;*&#x2F;*&quot; name&#x3D;&quot;file&quot; onchange&#x3D;&quot;fileChange()&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>不出所料，这样写还是没什么效果。</p><p>之后就是疯狂的<strong>Google</strong>，发现也有人遇到类似的问题，但是没有给出实质性的解决方案。</p><h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>发现知乎上有关于<a href="https://www.zhihu.com/question/21452742" target="_blank" rel="noopener">微信内置的浏览器如何上传文件？</a>的讨论。</p><p>也在其中找到了根本的解决原因。</p><p>这位兄台说，<code>accept=&quot;*/*&quot;</code>上传图片，在<strong>6.3.30</strong>版本不能触发<code>change</code>事件了，证明之前是可行。</p><p>微信浏览器团队在升级中引入了<strong>Bug</strong>，从<em>2016-11-14</em>至今也没修复。</p><p>然后我就将我的<code>accept</code>更改为<code>accept=&quot;image/*&quot;</code>果然就可行，鉴定是<strong>Bug</strong>无误。</p><p>但是我不仅要上传图片，任意格式都要支持啊，我果断把<code>accept</code>属性去掉了，测试居然所有类型都能支持上传了。</p><p>当初为什么要手贱写上<code>accept</code>属性，不然就不会搞到崩溃。</p><p>可是，仔细想想如果没有遇到这个<strong>Bug</strong>，也不会了解到微信内置浏览器(X5内核)也会出现这种想不到的<strong>Bug</strong>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>谁的程序都会出错，遇到问题就应该一个个的排除，总会找到解决问题的办法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不是一个笑话，微信浏览器真的有Bug。&lt;/p&gt;
&lt;p&gt;一个我觉得不应该出Bug的地方，它居然有&lt;strong&gt;Bug&lt;/strong&gt;，真的很坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信 input change" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1-input-change/"/>
    
  </entry>
  
  <entry>
    <title>移动端文件上传美化&amp;一键上传</title>
    <link href="http://yoursite.com/2018/05/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BE%8E%E5%8C%96-%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2018/05/06/移动端文件上传美化-一键上传/</id>
    <published>2018-05-05T16:48:57.000Z</published>
    <updated>2019-11-27T08:11:17.996Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中文件系统需要适配移动端，发现很多PC端的交互在移动端显得很累赘。</p><p>下面就改造一下<strong>文件上传</strong>，让它变得更加适合移动端。</p><a id="more"></a><h3 id="PC端实现方案"><a href="#PC端实现方案" class="headerlink" title="PC端实现方案"></a>PC端实现方案</h3><p>就拿上传文件来说，之前在移动端是<strong>点击上传icon</strong>，弹出一个对话框选择文件，然后通过对话框的按钮进行上传。</p><p>分解起来就是，选择文件和上传文件，其实是两步。但是在移动端，我们点击<code>input[file]</code>会调用原生的文件系统(iOS是选择照片/拍照上传)，<br>百度云的做法是在调用原生的文件系统，选择完要上传的文件，无需用户点击<strong>上传</strong>按钮直接上传。现在我们来学习下百度云的做法。</p><h3 id="美化input控件"><a href="#美化input控件" class="headerlink" title="美化input控件"></a>美化input控件</h3><p>在没有使用插件的原生<code>input[file]</code>是很难看的，上面的PC端上传文件是使用了<a href="https://github.com/kartik-v/bootstrap-fileinput" target="_blank" rel="noopener">file-input</a>组件，<br>所以我们自定义样式之后会显得比较好看。</p><p>但是在移动端我们不使用弹框效果了，所以<code>input[file]</code>也就没必要美化，直接隐藏就好。通过上传按钮调用<code>input[file]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;span class&#x3D;&quot;upload&quot; onclick&#x3D;&quot;chooseFile()&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;*&#x2F;*&quot; name&#x3D;&quot;uploadFile&quot; style&#x3D;&quot;display: none; opacity: 0&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JS</span><br><span class="line">function chooseFile() &#123;</span><br><span class="line">    var fileObj &#x3D; document.getElementsByName(&#39;uploadFile&#39;)[0];</span><br><span class="line">    fileObj.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上面的代码中，我们使用一个上传icon触发<code>input[file]</code>这样文件就选择完毕了</p><h3 id="一键上传"><a href="#一键上传" class="headerlink" title="一键上传"></a>一键上传</h3><p>现在文件选择完成了，我们发现没有办法<strong>上传文件</strong>了，因为<code>input[file]</code>已经被我们隐藏了。</p><p>让我们来转换一下思维方式，为什么还需要第二步上传操作，我们不能选择完成之后直接上传吗？事实证明百度云就是这么做的。</p><p><code>input[file]</code>也是一个普通的<code>input</code>，那我们就能使用它的<code>change</code>事件，这样就把思路捋顺了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;span class&#x3D;&quot;upload&quot; onclick&#x3D;&quot;chooseFile()&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;*&#x2F;*&quot; name&#x3D;&quot;uploadFile&quot; onchange&#x3D;&quot;uploadFile()&quot; style&#x3D;&quot;display: none; opacity: 0&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JS</span><br><span class="line">function chooseFile() &#123;</span><br><span class="line">    var fileObj &#x3D; document.getElementsByName(&#39;uploadFile&#39;)[0];</span><br><span class="line">    fileObj.click();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function uploadFile() &#123;</span><br><span class="line">    var formData &#x3D; new formData();</span><br><span class="line">    var fileObj &#x3D; document.getElementsByName(&#39;uploadFile&#39;)[0].files[0];</span><br><span class="line">    formData.appenf(&#39;file&#39;, fileObj);</span><br><span class="line"></span><br><span class="line">    axios.post(url, formData)</span><br><span class="line">        .then(function (res) &#123;</span><br><span class="line">            &#x2F;&#x2F; success</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function () &#123;</span><br><span class="line">            &#x2F;&#x2F; error</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为<code>input[file]</code>添加一个<code>change</code>事件，就能在我们选择完文件，自动调用相关函数进行上传。<br>在这里我没有使用原生的AJAX，我使用的是<a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">axios</a>，感兴趣的话可以自行Google。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此，我们就实现了一个简单移动端的上传文件，还有很多不足，会在后续工作中优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中文件系统需要适配移动端，发现很多PC端的交互在移动端显得很累赘。&lt;/p&gt;
&lt;p&gt;下面就改造一下&lt;strong&gt;文件上传&lt;/strong&gt;，让它变得更加适合移动端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>History API 使用指北</title>
    <link href="http://yoursite.com/2018/05/05/History-API-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/05/05/History-API-使用指北/</id>
    <published>2018-05-05T09:54:22.000Z</published>
    <updated>2019-11-27T08:11:17.994Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5 History API，基本上是为了SPA(单页应用)而生。</p><p>History API能够在不刷新页面的情况下，通过和<code>url</code>匹配历史堆栈中的数据取出来，这样就能大大减少数据请求，提高用户体验。</p><p>其实说实话，能不能提高用户体验，我不知道；在历史记录中切换（前进、后退）真的是如丝般顺滑。</p><a id="more"></a><h3 id="History-API-简介"><a href="#History-API-简介" class="headerlink" title="History API 简介"></a>History API 简介</h3><p>在浏览器环境下，我们可以通过<code>window.history</code>访问我们的浏览器访问历史。<br><br>可能说的有点问题，你只能得到三个值<code>length</code>,<code>scrollRestoration</code>和<code>state</code>。其中只有<code>state</code>的值是我们需要的，接下来会提到。</p><h4 id="back"><a href="#back" class="headerlink" title="back()"></a><code>back()</code></h4><p><code>back()</code>方法相当于点击浏览器的后退按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.back();</span><br></pre></td></tr></table></figure><h4 id="forward"><a href="#forward" class="headerlink" title="forward()"></a><code>forward()</code></h4><p><code>forward()</code>方法相当于点击浏览器的前进按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.forward();</span><br></pre></td></tr></table></figure><h4 id="go-n"><a href="#go-n" class="headerlink" title="go(n)"></a><code>go(n)</code></h4><p><code>go(n)</code>方法允许你在历史<strong>session</strong>前进或者后退<code>n</code>次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Go back two entries.</span><br><span class="line">window.history.go(-2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Go forward 3 entries.</span><br><span class="line">window.history.go(3);</span><br></pre></td></tr></table></figure><h4 id="length"><a href="#length" class="headerlink" title="length"></a><code>length</code></h4><p>就是我们上文在浏览器得到的<code>length</code>属性。</p><p>下面就是我们的重头戏，<strong>HTML5 History API</strong>，上面的属性方法只是简单的热身，你可能不需要热身。</p><h3 id="HTML5-History-API"><a href="#HTML5-History-API" class="headerlink" title="HTML5 History API"></a>HTML5 History API</h3><p>HTML5 History API包含两个方法和一个事件。</p><ul><li><code>pushState()</code></li><li><code>replaceState()</code></li><li><code>popstate</code></li></ul><p>在详细介绍之前，我们先来看看各个浏览器对于HTML5 History API支持情况。</p><p>可以说现在主流的浏览器对于HTML5 History API支持都是很好的，不过也要考虑向下兼容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!!history.pushState) &#123;</span><br><span class="line">    &#x2F;&#x2F; support</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; dont support</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pushState"><a href="#pushState" class="headerlink" title="pushState()"></a><code>pushState()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushState(state, title, url)</span><br></pre></td></tr></table></figure><ul><li><code>state</code>: 传递给<code>history.state</code></li><li><code>title</code>: 似乎浏览器还没有很好支持，传<code>null</code>就好</li><li><code>url</code>: 可选，这个参数会改变你的浏览器<code>url</code></li></ul><p>这个方法是在浏览器堆栈历史中<code>push</code>一条新的数据，然后将指针指向这条数据。</p><h4 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState()"></a><code>replaceState()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceState(state, title, url)</span><br></pre></td></tr></table></figure><p><code>replace()</code>方法与<code>pushState()</code>方法类似，主要是能够替换更新<code>pushState()</code>的<code>state</code>数据。</p><p>参数描述详见<code>pushState()</code>的描述。</p><h4 id="popstate事件"><a href="#popstate事件" class="headerlink" title="popstate事件"></a><code>popstate</code>事件</h4><p>当用户点击浏览器的前进/后退按钮，<code>popstate</code>事件会被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;popstate&#39;, function (event) &#123;</span><br><span class="line">    &#x2F;&#x2F; update the page content</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; or </span><br><span class="line">window.onpopstate &#x3D; function (event) &#123;</span><br><span class="line">    &#x2F;&#x2F; update the page content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就把<strong>History API</strong>简略介绍了一下，详细说明请访问<a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" rel="noopener">MDN</a>。</p><h3 id="手把手实战"><a href="#手把手实战" class="headerlink" title="手把手实战"></a>手把手实战</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>网上也不乏介绍H5 History API应用的文章，大概也都是比较简单的Demo。</p><p>点击链接<strong>first、second、third..</strong>,<code>url</code>会改变为<code>http://html5demos.com/history#fitst</code>,<code>http://html5demos.com/history#second</code>…</p><p>获取不同<code>#first</code>,<code>#second</code>的数据，渲染页面中的数据。具体实现<a href="http://blog.teamtreehouse.com/getting-started-with-the-history-api" target="_blank" rel="noopener">源码</a>。</p><p>本文，我想介绍的不是这种demo，而是比较实际的项目开发。</p><p>实现一个文件系统的浏览页面，通过<code>url</code>哈希值<code>#...</code>记录文件夹的路径。</p><p>例如，<code>www.demo.com/filesystem.html#abc/</code>就是根目录下<code>abc</code>文件夹；<code>www.demo.com/filesystem.html#abc/def/</code>代表<code>abc</code>文件夹下的<code>def</code>文件夹。</p><p>如上图，该目录下有文件和文件夹，点击<strong>文件</strong>会直接在浏览器打开该文件或者下载，点击<strong>文件夹</strong>会进入该文件夹，页面显示该文件夹的内容。</p><p>这样就需要我们把<code>url</code>的<code>hash</code>值动态改变，然后根据<code>hash</code>值确定所在文件路径向后台获取资源。</p><h4 id="前后端接口API"><a href="#前后端接口API" class="headerlink" title="前后端接口API"></a>前后端接口API</h4><h5 id="显示目录"><a href="#显示目录" class="headerlink" title="显示目录"></a>显示目录</h5><p>请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;api&#x2F;v1&#x2F;fileproxy&#x2F;pub&#x2F;abc&#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure></p><p>响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: 0,</span><br><span class="line">    &quot;errormsg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a.txt&quot;,</span><br><span class="line">            &quot;size&quot;: 1234,</span><br><span class="line">            &quot;time&quot;: 1235153531,</span><br><span class="line">            &quot;isdir&quot;: false,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a.txt&quot;,</span><br><span class="line">            &quot;size&quot;: 1234,</span><br><span class="line">            &quot;time&quot;: 1235153531,</span><br><span class="line">            &quot;isdir&quot;: false,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="打开-下载文件"><a href="#打开-下载文件" class="headerlink" title="打开/下载文件"></a>打开/下载文件</h5><p>请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;api&#x2F;v1&#x2F;fileproxy&#x2F;pub&#x2F;abc&#x2F;a.txt HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure></p><p>从后端获取到的文件信息包括<code>name</code>文件(夹)名,<code>size</code>大小,<code>time</code>修改时间,<code>isdir</code>是否是文件夹。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li><code>initGetfile()</code></li><li><code>openDir(str)</code></li><li><code>window.onpopstate</code></li></ul><p><code>initGetfile()</code>函数，首次进入或者刷新页面自动执行该函数，渲染文件列表。</p><p><code>openDir(str)</code>函数，当点击文件夹时调用该函数，获取新的文件列表。</p><p><code>window.onpopstate</code>也就是<code>popstate</code>事件。</p><p>在没有使用<code>History API</code>时，是通过<code>hashchange</code>事件来触发文件列表的更新，这就导致每一次前进后退都会发起一次<code>ajax</code>请求，没有把之前请求过的数据进行缓存，影响用户体验。</p><blockquote><p>对了在此要声明一下，<code>psuhState()</code>和<code>replaceState()</code>不会触发<code>hashchange</code>事件</p></blockquote><p>怎么理解呢，就是当你通过<code>psuhState()</code>和<code>replaceState()</code>的第三个参数<code>url</code>对于hash值有更改的时候，也不会触发<code>hashchange</code>事件。</p><p><strong>Chrome 和 Safari浏览器在重载页面的时候会触发<code>popstate</code>事件，Firefox浏览器不会。</strong></p><h4 id="重头戏"><a href="#重头戏" class="headerlink" title="重头戏"></a>重头戏</h4><p>下面将会贴上我的代码，使用Vue2 和 <a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">axios</a>实现。</p><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;file-list&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;weui-cells&quot;&gt;</span><br><span class="line">        &lt;a v-if&#x3D;&quot;fileList.length&quot; v-for&#x3D;&quot;item in fileList&quot; href&#x3D;&quot;javascript:;&quot; class&#x3D;&quot;weui-cell weui-cell_access&quot;&gt;</span><br><span class="line">                &lt;!-- Dir --&gt;</span><br><span class="line">                &lt;div v-if&#x3D;&quot;item.isdir&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;weui-cell__hd&quot;&gt;</span><br><span class="line">                        &lt;span class&#x3D;&quot;icon-size an-folder&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt; </span><br><span class="line">                    &lt;div class&#x3D;&quot;weui-cell__bd&quot; @click&#x3D;&quot;openDir(item)&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;!-- File --&gt;</span><br><span class="line">                &lt;div v-else&gt;</span><br><span class="line">                    &lt;div v-else class&#x3D;&quot;weui-cell__hd&quot;&gt;</span><br><span class="line">                        &lt;span class&#x3D;&quot;icon-size an-file&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;weui-cell__bd&quot; @click&#x3D;&quot;openFile(item)&quot;&gt;</span><br><span class="line">                        &lt;p&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a v-if&#x3D;&quot;!fileList.length&quot; class&#x3D;&quot;weui-cell weui-cell_access&quot; href&#x3D;&quot;javascript:;&quot;&gt; </span><br><span class="line">            &lt;div class&#x3D;&quot;weui-cell__bd&quot;&gt; </span><br><span class="line">                    &lt;p&gt;No such file or directory&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>将文件夹和文件分成两类进行渲染，绑定不同的点击函数，并传递参数为文件(夹)名，前面的前后端API也提示我们是通过<code>name</code>进行请求。</p><h5 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">(function (exports) &#123;</span><br><span class="line">    exports.app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;.file-list&#39;,</span><br><span class="line"></span><br><span class="line">        data: &#123;</span><br><span class="line">            haveFile: true,</span><br><span class="line">            fileList: [],</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        mounted: fucntion () &#123;  &#x2F;&#x2F; 挂载之后，自动执行</span><br><span class="line">            this.$nextTick(function () &#123;</span><br><span class="line">                this.initGetfile();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;，</span><br><span class="line"></span><br><span class="line">        methods: &#123;</span><br><span class="line">            initGetfile: function () &#123;</span><br><span class="line">                var _this &#x3D; this;</span><br><span class="line">                var hash &#x3D; _this.getHash();</span><br><span class="line">                var url &#x3D; &#39;&#x2F;api&#x2F;v1&#x2F;fileproxy&#x2F;&#39; + hash;</span><br><span class="line">                axios.get(url)</span><br><span class="line">                    .then(function (res)&#123;</span><br><span class="line">                        _this.fileList &#x3D; res.data.data;</span><br><span class="line">                        </span><br><span class="line">                        &#x2F;&#x2F; replaceState()</span><br><span class="line">                        history.replaceState(_this.fileList, null);</span><br><span class="line"></span><br><span class="line">                        if (!res.data.data.length) &#123;</span><br><span class="line">                            _this.haveFile &#x3D; false;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            _this.haveFile &#x3D; true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            openDir: function (item) &#123;</span><br><span class="line">                var _this &#x3D; this;</span><br><span class="line">                _this.loadFile &#x3D; true;</span><br><span class="line">                var hash &#x3D; _this.getHash();</span><br><span class="line">                var url &#x3D; &#39;&#x2F;api&#x2F;v1&#x2F;fileproxy&#x2F;-&#x2F;&#39; + hash + item.name +&#39;&#x2F;&#39;;</span><br><span class="line"></span><br><span class="line">                axios.get(url)</span><br><span class="line">                    .then(function (res) &#123;</span><br><span class="line">                        _this.fileList &#x3D; res.data.data;</span><br><span class="line">                       </span><br><span class="line">                        _this.loadFile &#x3D; false;</span><br><span class="line"></span><br><span class="line">                        var newUrl &#x3D; window.location.href + item.name + &#39;&#x2F;&#39;;</span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F; pushState()</span><br><span class="line">                        history.pushState(_this.fileList,null, newUrl);</span><br><span class="line"></span><br><span class="line">                        if (!res.data.data.length) &#123;</span><br><span class="line">                            _this.haveFile &#x3D; false;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            _this.haveFile &#x3D; true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            openFile: function (item) &#123;</span><br><span class="line">                var _this &#x3D; this;</span><br><span class="line">                var hash &#x3D; _this.getHash();</span><br><span class="line">                var url &#x3D; &#39;&#x2F;api&#x2F;v1&#x2F;fileproxy&#x2F;-&#x2F;&#39; + hash + item.name;</span><br><span class="line">                window.open(url);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            getHash: function () &#123;</span><br><span class="line">                var hash &#x3D; window.location.hash.substr(1);</span><br><span class="line">                if (hash.substr(-1) !&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">                    hash +&#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">                return hash;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    window.onpopstate &#x3D; function (e) &#123;</span><br><span class="line">        console.log(&#39;pop state&#39;);</span><br><span class="line">        console.log(&#39;state&#39;, JSON.stringify(e.state));</span><br><span class="line">        if (e.state !&#x3D; null) &#123;</span><br><span class="line">            app.fileList &#x3D; e.state;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            window.location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>以上就是我完成基本功能的源码，添加<strong>History API</strong>到项目中并没有做太多改动：</p><ol><li><p>增加<code>pushState()</code>和<code>repalceState()</code>函数</p></li><li><p>替换原有的<code>hashchange</code>事件为<code>popstate</code>事件。</p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本没有对源码做过多的分析，因为可能需求不一样采取的处理方法也不一样，我只是提供一个<code>#abc/def...</code>这种hash值比较复杂需求的一种实现。</p><p>希望能够对你有所启发，也是现学现卖，如有不妥之处，望指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5 History API，基本上是为了SPA(单页应用)而生。&lt;/p&gt;
&lt;p&gt;History API能够在不刷新页面的情况下，通过和&lt;code&gt;url&lt;/code&gt;匹配历史堆栈中的数据取出来，这样就能大大减少数据请求，提高用户体验。&lt;/p&gt;
&lt;p&gt;其实说实话，能不能提高用户体验，我不知道；在历史记录中切换（前进、后退）真的是如丝般顺滑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTML5 History" scheme="http://yoursite.com/tags/HTML5-History/"/>
    
  </entry>
  
  <entry>
    <title>高效JavaScript-68诫</title>
    <link href="http://yoursite.com/2018/04/25/%E9%AB%98%E6%95%88JavaScript-68%E8%AF%AB/"/>
    <id>http://yoursite.com/2018/04/25/高效JavaScript-68诫/</id>
    <published>2018-04-25T06:04:04.000Z</published>
    <updated>2019-11-27T13:23:56.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。"><a href="#将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。" class="headerlink" title="将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。"></a>将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。</h1><h3 id="让自己习惯JavaScript"><a href="#让自己习惯JavaScript" class="headerlink" title="让自己习惯JavaScript"></a>让自己习惯<code>JavaScript</code></h3><ol><li>了解你使用的JavaScript版本</li><li>理解JavaScript的浮点数</li><li>当心隐式的强制转换</li><li>原始类型优于封装对象</li><li>避免对混合类型使用<code>==</code>运算符</li><li>了解分号插入的局限</li><li>视字符串为16位的代码单元序列</li></ol><a id="more"></a><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ol><li>尽量少用全局对象</li><li>始终声明局部变量</li><li>避免使用<code>with</code></li><li>熟练掌握闭包</li><li>理解变量声明提升</li><li>使用立即调用的函数表达式创建局部函数</li><li>当心命名函数表达式笨拙的作用域</li><li>当心局部块函数声明笨拙的作用域</li><li>避免使用<code>eval</code>创建局部变量</li><li>间接调用<code>eval</code>函数优于直接调用</li></ol><h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><ol><li>理解函数调用、方法调用及构造函数</li><li>熟练掌握高阶函数</li><li>使用<code>call</code>方法自定义接收者来调用函数</li><li>使用<code>apply</code>方法通过不同数量的参数调用函数</li><li>使用<code>arguments</code>创建可变参数的函数</li><li>永远不要修改<code>arguments</code>对象</li><li>使用变量保存<code>arguments</code>的引用</li><li>使用<code>bind</code>方法提取具有确定接收者的方法</li><li>使用<code>bind</code>方法实现函数柯里化</li><li>使用闭包而不是字符串来封装代码</li><li>不要信赖函数对象的<code>toString</code>方法</li><li>避免使用非标准的栈检查属性</li></ol><h3 id="对象和原型"><a href="#对象和原型" class="headerlink" title="对象和原型"></a>对象和原型</h3><ol><li>理解<code>prototype</code>、<code>getPrototypeOf</code>和<code>__proto__</code>之间的不同</li><li>使用<code>Object.getPrototypeOf</code>函数而不要使用<code>__proto__</code>属性</li><li>始终不要修改<code>__proto__</code>属性</li><li>使构造函数与<code>new</code>操作符无关</li><li>在原型中存储方法</li><li>使用闭包存储私有数据</li><li>只将实例状态存储在实例对象中</li><li>认识到<code>this</code>变量的隐式绑定问题</li><li>在子类的构造函数中调用父类的构造函数</li><li>不要重用父类的属性名</li><li>避免继承标准类</li><li>将原型视为实现细节</li><li>避免使用轻率的<strong>猴子补丁</strong>(monkey-patching)</li></ol><h3 id="数组和字典"><a href="#数组和字典" class="headerlink" title="数组和字典"></a>数组和字典</h3><ol><li>使用<code>Object</code>的直接实例构造轻量级的字典</li><li>使用<code>null</code>原型以防止原型污染</li><li>使用数组而不要使用字典存储有序集合</li><li>使用<code>hasOwnProperty</code>方法以避免原型污染</li><li>使用数组而不要使用字典来存储有序集合</li><li>绝不要在<code>Object.prototype</code>中增加可枚举的属性</li><li>避免在枚举期间修改对象</li><li>数组迭代要优先使用<code>for</code>循环而不是<code>for...in</code>循环</li><li>迭代方法由于循环</li><li>在类数组对象上复用通用的数组方法</li><li>数组字面量优于数组构造函数</li></ol><h3 id="库和API设计"><a href="#库和API设计" class="headerlink" title="库和API设计"></a>库和API设计</h3><ol><li>保持一致的约定</li><li>将<code>undefined</code>看做“没有值”</li><li>接收关键字参数的选项对象</li><li>避免不必要的状态</li><li>使用结构类型设计灵活的接口</li><li>区分数组对象和类数组对象</li><li>避免过度的强制转换</li><li>支持方法链</li></ol><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol><li>不要阻塞I/O事件队列</li><li>在异步序列中使用嵌套或命名的回调函数</li><li>当心丢弃错误</li><li>对异步循环使用递归</li><li>不要在计算时阻塞事件队列</li><li>使用计数器来执行并行操作</li><li>绝不要同步的调用异步的回调函数</li><li>使用<code>promise</code>模式清洁异步逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。&quot;&gt;&lt;a href=&quot;#将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。&quot; class=&quot;headerlink&quot; title=&quot;将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。&quot;&gt;&lt;/a&gt;将《编写高质量JavaScript代码的68个有效方法》书中提到的68个方法分享给大家。&lt;/h1&gt;&lt;h3 id=&quot;让自己习惯JavaScript&quot;&gt;&lt;a href=&quot;#让自己习惯JavaScript&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯JavaScript&quot;&gt;&lt;/a&gt;让自己习惯&lt;code&gt;JavaScript&lt;/code&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;了解你使用的JavaScript版本&lt;/li&gt;
&lt;li&gt;理解JavaScript的浮点数&lt;/li&gt;
&lt;li&gt;当心隐式的强制转换&lt;/li&gt;
&lt;li&gt;原始类型优于封装对象&lt;/li&gt;
&lt;li&gt;避免对混合类型使用&lt;code&gt;==&lt;/code&gt;运算符&lt;/li&gt;
&lt;li&gt;了解分号插入的局限&lt;/li&gt;
&lt;li&gt;视字符串为16位的代码单元序列&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书·读书笔记</title>
    <link href="http://yoursite.com/2018/04/25/JS%E7%BA%A2%E5%AE%9D%E4%B9%A6%C2%B7%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/25/JS红宝书·读书笔记/</id>
    <published>2018-04-25T05:53:57.000Z</published>
    <updated>2019-11-27T08:11:17.995Z</updated>
    
    <content type="html"><![CDATA[<p>花了半个多月的时间，终于又把“JS红宝书”又撸了一遍。</p><p>第一次读“JS红宝书”还是<strong>2015</strong>年初学JS的时候，那时候只是把语法部分读了一遍，还有一些浏览器相关知识做了下了解，大概也就读了半本的样子，<br>就开始了用JS进行开发了，在成长的道路上遇见了<strong>JQuery</strong>，当时真的是感觉到<strong>JQuery</strong>太友好了，慢慢放下了原生开发。</p><p>现在呢，更多的时候是在用框架进行开发，越来越觉得自己的JS基础很缺乏，然后就开启了“JS红宝书”二刷之路。</p><p>下面就把书中自己觉得重要的、没有掌握的知识整理出来。因为我觉得还是会三刷“JS红宝书”，希望把这本700多页的书越读越薄，勉励。</p><a id="more"></a><h2 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h2><hr><h3 id="async"><a href="#async" class="headerlink" title="async"></a><code>async</code></h3><p>加载外部脚本文件，通知浏览器立即下载，异步执行。</p><h3 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a><code>noscript</code>元素</h3><p><code>noscript</code>标签显示条件：</p><ul><li>浏览器不支持脚本</li><li>浏览器支持脚本，但是脚本被禁用</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul><li>第一个字符必须是一个字母、下划线或者一个美元符号</li><li>其他字符可以是字母、下划线、美元或者数字</li></ul><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>支持严格模式的浏览器包括：IE10+、Firefox4+、Safari 5.1+、Opera 12+和Chrome。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>对未初始化的变量执行<code>typeof</code>操作会返回<code>undefined</code>值，而对于未声明的变量执行<code>typeof</code>操作同样会返回<code>undefined</code>值。</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span><span class="comment">// -&gt; object</span></span><br></pre></td></tr></table></figure><p><strong>undefined</strong>值派生自<code>null</code>值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == undefind)<span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure></p><h4 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h4><p>测试一个数值是不是无穷值。</p><p><code>Number.NEGATIVE_INFINITY</code>：负无穷<br><code>Number.POSITION_INFINITY</code>：正无穷</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>在ECMAScript中，任何数值除以0会返回<code>NaN</code>。</p><p><code>isNaN()</code>接受一个参数，确定这个参数是否”不是数值”。</p><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p><code>Number()</code></p><ul><li>如果是<code>null</code>，返回<code>0</code></li><li>如果是<code>undefined</code>，返回<code>NaN</code></li></ul><p><code>parseInt()</code><br>在ES5 中不支持解析八进制的能力。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'070'</span>);<span class="comment">// -&gt; 70 not 56</span></span><br></pre></td></tr></table></figure><br>通过第二个参数，指定转换基数（进制）默认十进制。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>ECMAScript中的字符串是不可变的</li><li><code>toString()</code></li></ul><p>在调用数值的<code>toString</code>方法，可以传递一个参数：输出数值的基数。没有<code>toString</code>方法的则返回该值的字面量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));<span class="comment">// -&gt; '1010'</span></span><br></pre></td></tr></table></figure></p><h4 id="object类型"><a href="#object类型" class="headerlink" title="object类型"></a>object类型</h4><p>Object类型的属性方法：</p><ul><li>constructor</li><li>hasOwnProperty(propertyName)</li><li>isPrototypeOf(obj)</li><li>propertyIsEnumerable(propertyName)</li><li>toLocalString()</li><li>toString()</li><li>valueOf()</li></ul><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul><li><code>++</code> or <code>--</code></li></ul><p>前置与后置的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num3 = --num1 + num2;<span class="comment">// 21</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2;<span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num6 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num7 = num5-- + num6;<span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> num8 = num5 + num6;<span class="comment">// 21</span></span><br></pre></td></tr></table></figure></p><ul><li>一元加操作符用于强制类型转换，隐式<code>Number()</code>效果</li></ul><h4 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h4><p><code>for-in</code>语句是一种精确的迭代语句，可以用来枚举对象的属性。</p><p>通过<code>for-in</code>循环输出的属性名的顺序是不可预测的。</p><p>如果要迭代的对象的变量值为<code>null</code>或<code>undefined</code>，<code>for-in</code>语句会抛出错误。<strong>ES5</strong>更正了这一行为，不再抛出错误，只是不再执行循环体。</p><p><strong>建议</strong>：在是使用<code>for-in</code>循环之前，先检查对象值是不是<code>null</code>或者<code>undefined</code>。</p><h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><hr><h3 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h3><h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><ul><li>复制基本类型值，这两个变量相互独立，互不影响。</li><li>复制引用类型（对象），值引用是一个指针，改变其中一个对象，会影响另一个对象。</li></ul><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure><p>以上代码中创建一个对象，并将其保存在了变量<code>person</code> 中。然后，这个变量被传递到<code>setName()</code>函数中之后就被复制给了<code>obj</code>。在这个函数部，<code>obj</code> 和<code>person</code> 引用的是同一个对象。换句话说，即使这个变量是按值传递的，<code>obj</code> 也会按引用来访问同一个对象。于是，当在函数内部为<code>obj</code> 添加<code>name</code>属性后，函数外部的<code>person</code> 也将有所反映；因为<code>person</code> 指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure><br>这个例子与前一个例子的唯一区别，就是在<code>setName()</code>函数中添加了两行代码：一行代码为<code>obj</code>重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的<code>name</code>属性。在把<code>person</code>传递给<code>setName()</code>后，其<code>name</code> 属性被设置为”Nicholas”。然后，又将一个新对象赋给变量<code>obj</code>，同时将其<code>name</code>属性设置为”Greg”。如果<code>person</code> 是按引用传递的，那么<code>person</code> 就会自动被修改为指向其<code>name</code>属性值为”Greg”的新对象。但是，当接下来再访问<code>person.name</code> 时，显示的值仍然是”Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写<code>obj</code>时，这个变量引用的就是一个局部对象了。<strong>而这个局部对象会在函数执行完毕后立即被销毁。</strong></p><h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><p>虽然在检测基本数据类型时<code>typeof</code> 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了<code>instanceof</code> 操作符。</p><h4 id="延长作用域"><a href="#延长作用域" class="headerlink" title="延长作用域"></a>延长作用域</h4><ul><li><code>try-catch</code>语句中的<code>catch</code>块</li><li><code>with</code>语句</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><hr><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript5新增了 <code>Array.isArray()</code>方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h4><p>该方法有缺陷，<code>sort()</code>方法会调用每个数组项的<code>toString()</code>转型方法，然后比较字符串进行排序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure><br>因此<code>sort()</code>方法接受一个比较函数作为参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure></p><h4 id="splice方法"><a href="#splice方法" class="headerlink" title="splice方法"></a>splice方法</h4><p><code>splice</code>方法始终返回一个数组，该数组包含了从原始数组中删除的项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,blue</span></span><br><span class="line">alert(removed); <span class="comment">// red，返回的数组中只包含一项</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>); <span class="comment">// 从位置1 开始插入两项</span></span><br><span class="line">alert(colors); <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">// 返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>); <span class="comment">// 插入两项，删除一项</span></span><br><span class="line">alert(colors); <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">// yellow，返回的数组中只包含一项</span></span><br></pre></td></tr></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>ECMAScript5为数组定义了5个迭代方法。</p><ul><li><code>every()</code>: 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li><li><code>filter()</code>: 对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。</li><li><code>forEach()</code>: 对数组中的每一项运行给定函数。这个方法没有返回值。</li><li><code>map()</code>: 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li><li><code>some()</code>: 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li></ul><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><p>ECMAScript 5 还新增了两个归并数组的方法。</p><ul><li><code>reduce()</code></li><li><code>reduceRight()</code><br><code>reduce()</code>和<code>reduceRight()</code>的函数接收4 个参数：前一个值、当前值、项的索引和数组对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3></li></ul><h4 id="正则表达式中的元字符"><a href="#正则表达式中的元字符" class="headerlink" title="正则表达式中的元字符"></a>正则表达式中的元字符</h4><p><code>( [ { \ ^ $ | ) ? * + . ] }</code></p><p><strong>注</strong>：匹配元字符必须转义</p><h4 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a><code>RegExp</code> 构造函数</h4><p>接受两个参数： 一个是要匹配的字符串模式，另一个是可选的标志字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'[bc]at'</span>, <span class="string">'i'</span>);</span><br></pre></td></tr></table></figure><br><strong>注</strong>：由于RegExp构造函数的模式是字符串，所以在某些情况下要对字符串进行双重转义，所有元字符都必须双重转义。例如<code>\n</code>在字符串中被转义为<code>\\n</code>，而在正则表达式字符串中就会变成<code>\\\\n</code>。</p><h4 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a><code>RegExp</code>实例方法</h4><h5 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a><code>exec()</code>方法</h5><p>该方法是专门为捕获组而设计的。<code>exec()</code>接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回<code>null</code>。返回的数组虽然是Array 的实例，但包含两个额外的属性：<code>index</code> 和<code>input</code>。其中，<code>index</code> 表示匹配项在字符串中的位置，而<code>input</code> 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">// 0</span></span><br><span class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></span><br><span class="line">aler t(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure></p><p>对于<code>exec()</code>方法而言，即使在模式中设置了全局标志（<code>g</code>），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用<code>exec()</code>将始终返回第一个匹配项的信息。而在<strong>设置</strong>全局标志的情况下，每次调用<code>exec()</code>则都会在字符串中继续查找新匹配项。</p><h5 id="test-方法"><a href="#test-方法" class="headerlink" title="test()方法"></a><code>test()</code>方法</h5><p>接受一个字符串参数。在模式与该参数匹配的情况下返回<code>true</code>；否则，返回<code>false</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">alert(<span class="string">"The pattern was matched."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RegExp实例继承的<code>toLocaleString()</code>和<code>toString()</code>方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>);</span><br><span class="line">alert(pattern.toString()); <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line">alert(pattern.toLocaleString()); <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure></p><h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unexpected identifier(意外标识符)</span></span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>：要访问函数的指针而不执行函数的话，必须去掉函数名后的那对圆括号。</p><h4 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h4><ul><li><code>arguments</code></li><li><code>this</code></li></ul><p><code>arguments</code>具有一个<code>callee</code>属性，该属性是一个指针，指向拥有这个<code>arguments</code>对象的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>达到一种解耦的效果。</p><p>ECMAScript 5也规范了一个函数对象属性：<code>caller</code>(看着很像<code>callee</code>)，这个属性中保存着调用当前函数的函数的引用，如果实在全局作用域中调用当前函数，它的值为<code>null</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><br><code>inner.caller</code>指向<code>outer()</code>。为了实现更松散的耦合，也可以通过<code>argument.callee.caller</code>来访问相同的信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>：当函数在<strong>严格模式</strong>下运行时，访问<code>arguments.callee</code> 会导致错误。ECMAScript 5 还定义了<code>arguments.caller</code>属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是<code>undefined</code>。定义这个属性是为了分清<code>arguments.caller</code> 和函数的<code>caller</code> 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。<br><strong>严格模式</strong>还有一个限制：不能为函数的<code>caller</code> 属性赋值，否则会导致错误。</p><h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4><p>每个函数都包含两个属性:</p><ul><li><code>length</code>: 表示函数希望接收的命名参数的个数</li><li><code>prototype</code>: 保存实例方法</li></ul><p>每个函数都包含两个非继承而来的方法：</p><ul><li><code>apply()</code></li><li><code>call()</code><br>这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内<code>this</code> 对象的值。首先，<code>apply()</code>方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是<code>Array</code> 的实例，也可以是<code>arguments</code>对象。<br><code>call()</code>方法与<code>apply()</code>方法的作用相同，它们的区别仅在于接收参数的方式不同。对于<code>call()</code>方法而言，第一个参数是<code>this</code> 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用<code>call()</code>方法时，传递给函数的参数必须逐个列举出来。</li></ul><p><strong>注</strong>：在严格模式下，未指定环境对象而调用函数，则<code>this</code> 值不会转型为<code>window</code>。除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>，否则this 值将是<code>undefined</code>。</p><p>在非严格模式下，<code>call</code>、<code>apply</code>的第一个参数传递为<code>null</code>或<code>undefined</code>时，函数体内的<code>this</code>会指向默认的宿主对象，在浏览器中则是<code>window</code>。</p><p><strong>ECMAScript 5</strong>定义了一个方法<code>bind()</code>，这个方法会创建一个函数的实例，其<code>this</code>值会被绑定到传给<code>bind()</code>函数的值。</p><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>使用<code>new</code>调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'25'</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value);<span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number);<span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure></p><h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>Number类型的<code>toString()</code>方法很特别，可以传递一个表示基数的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString()); <span class="comment">//"10"</span></span><br><span class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">//"1010"</span></span><br><span class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">//"12"</span></span><br><span class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">//"10"</span></span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">//"a"</span></span><br></pre></td></tr></table></figure></p><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><h5 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h5><ul><li><code>charAt()</code></li><li><code>charCodeAt()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">//"e"</span></span><br><span class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">//输出字符编码"101"</span></span><br></pre></td></tr></table></figure><h5 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h5><ul><li><code>concat()</code></li><li><code>slice()</code></li><li><code>substr()</code></li><li><code>substring()</code></li></ul><p>这些方法对原字符均没有任何影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line">alert(result); <span class="comment">//"hello world!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>)); <span class="comment">//"lo world"</span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo worl"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是负值的情况下，它们的行为就不尽相同了。</span></span><br><span class="line"><span class="comment">// 其中，slice()方法会将传入的负值与字符串的长度相加，</span></span><br><span class="line"><span class="comment">// substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。</span></span><br><span class="line"><span class="comment">// 最后，substring()方法会把所有负值参数都转换为0。</span></span><br><span class="line">alert(stringValue.slice(<span class="number">-3</span>)); <span class="comment">//"rld"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">-3</span>)); <span class="comment">//"hello world"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">-3</span>)); <span class="comment">//"rld"</span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"lo w"</span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"hel"</span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//""（空字符串）</span></span><br></pre></td></tr></table></figure><h5 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h5><ul><li><code>indexOf()</code></li><li><code>lastIndexOf()</code></li></ul><p>两个方法的第二个参数，表示从字符串中哪个位置开始搜索。</p><h5 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h5><p><strong>ECMAScript 5</strong>方法</p><h5 id="字符串转换大小写方法"><a href="#字符串转换大小写方法" class="headerlink" title="字符串转换大小写方法"></a>字符串转换大小写方法</h5><ul><li><code>toLowerCase()</code></li><li><code>toLocaleLowerCase()</code></li><li><code>toUpperCase()</code></li><li><code>toLocaleUpperCase()</code></li></ul><h5 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h5><ul><li><code>match()</code></li><li><code>search()</code></li><li><code>replace()</code></li><li><code>split()</code></li></ul><p><code>match()</code>方法，在字符串上调用这个方法，本质上和调用<code>RegExp</code>的<code>exec()</code>方法相同。<code>match()</code>方法只接受一个参数，要么是一个正则表达式，要么是一个<strong>RegExp</strong>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cat, bat, sat, fat'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 pattern.exec(text)</span></span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//"cat"</span></span><br><span class="line">alert(pattern.lastIndex); <span class="comment">//0</span></span><br></pre></td></tr></table></figure></p><p><code>search()</code>方法的参数与<code>match()</code>方法相同，该方法返回字符串中第一个匹配项的索引，没有匹配项返回<code>-1</code>；个人认为<code>serch()</code>就是正则版的<code>indexOf()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line">aler t(pos); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p><strong>ECMAScript</strong>提供了<code>replace()</code>方法，该方法接受两个参数，第一个参数可以是<strong>RegExp</strong>对象或者是一个字符串，第二个参数可以是一个字符串或者一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bat, sat, fat"</span></span><br><span class="line"></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</span><br><span class="line">aler t(result); <span class="comment">//"cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure><br>| 字符序列 | 替换文本 |<br>| : - : | : – : |<br>| <code>$$</code> | <code>$</code> |<br>| <code>$&amp;</code> | 匹配整个模式的子字符串。RegExp.lastMatch |<br>| <code>$&#39;</code> | 匹配子字符串之前的字符串。RegExp.leftContext |<br>| $<code>| 匹配的子字符串之后的字符串。 RegExp.rightContext ||</code>$n<code>| 匹配第n个捕获组的子字符串 n: 0~9 ||</code>$nn` | 匹配第nn个捕获组的子字符串 nn: 01~99 |</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>);</span><br><span class="line">alert(result); <span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure><p><code>split()</code>方法可以基于指定的分隔符(字符串 or RegExp对象)将一个字符串分割成多个子字符串，并将结构放在一个数组中。可以接受可选的第二个参数，用于指定数组的大小。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">//["red", "blue", "green", "yellow"]</span></span><br><span class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">//["red", "blue"]</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure></p><h5 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h5><p>比较两个字符串，并返回下列值中的 一个：</p><ul><li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数</li><li>如果字符串等于字符串参数，则返回0；</li><li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;</span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"brick"</span>)); <span class="comment">//1</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"yellow"</span>)); <span class="comment">//0</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"zoo"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure><h5 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h5><p>这个方法的任务是接收一个或多个字符编码，然后将它们转换成一个字符串。相当于<code>charCodeAt()</code>反操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure></p><h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><ul><li><code>min()</code></li><li><code>max()</code></li><li><code>ceil()</code></li><li><code>floor()</code></li><li><code>round()</code></li><li><code>random()</code></li></ul><h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><h5 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li><code>[[Configurable]]</code>: 表示能否通过<code>delete</code>删除属性从而重新定义属性，能够修改属性的特性，或者能否把属性修改为访问器属性</li><li><code>[[Enumerable]]</code>: 表示能否通过<code>for-in</code>循环返回属性</li><li><code>[[Writable]]</code>: 表示能否修改属性的值</li><li><code>[[Value]]</code>: 包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值<code>undefined</code></li></ul><p>要修改属性默认的特性，必须使用<strong>ECMAScript 5</strong>的<code>Object.defineProperty()</code>方法。这个方法接受三个参数：属性所在对象，属性名和一个描述符对象。其中描述符对象的属性值必须是：<code>configurable</code>、<code>enumerable</code>、<code>writable</code>和<code>value</code>。设置其中一个或多个。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">writable: <span class="literal">false</span>,</span><br><span class="line">value: <span class="string">'Yeaseon'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><code>Object.defineProperty()</code>方法不能对<code>configurable: false</code>的对象进行修改。</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul><li><code>[[Configurable]]</code>: 表示能否通过<code>delete</code>删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</li><li><code>[[Enumerable]]</code>: 表示能否通过<code>for-in</code>循环返回属性。</li><li><code>[[Get]]</code>: 在读取属性时调用的函数，默认<code>undefined</code></li><li><code>[[Set]]</code>: 在写入属性时调用的函数，默认<code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">_year: <span class="number">2004</span>,</span><br><span class="line">edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line"><span class="keyword">get</span>: function()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line"><span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>._year = newValue;</span><br><span class="line"><span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p><strong>ECMAScript 5</strong>的<code>Object.getOwnPropertyDescriptor()</code>方法，可以取得给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取器描述符的属性名称，返回值是对象。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure><p><code>Person.prototype.constructor</code>会指向<code>Person</code>，<code>person1</code>并没有直接连接到构造函数<code>Person</code>。</p><ul><li>可以通过<code>isPrototypeOf()</code>方法来确定对象之间是否存在原型关系。从本质上讲，<code>[[Prototype]]</code>指向调用<code>isPrototypeOf()</code>方法的对象<code>Person.prototype</code>，则会返回<code>true</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>在<strong>ECMAScript 5</strong>增加了<code>Object.getPrototypeOf()</code>方法，该方法返回<code>[[Prototype]]</code>的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><p><strong>注</strong>: 虽然可以通过对象实例<code>person1</code>访问保存在原型中的值，但却不能重写原型中的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"Greg"</span>; <span class="comment">//实质是在实例上增加一个name属性</span></span><br><span class="line">alert(person1.name); <span class="comment">//"Greg"——来自实例</span></span><br><span class="line">alert(person2.name); <span class="comment">//"Nicholas"——来自原型</span></span><br></pre></td></tr></table></figure><br>可以通过<code>delete</code>删除实例属性，从而继续访问原型中的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name); <span class="comment">//"Greg"——来自实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.name); <span class="comment">//"Nicholas"——来自原型</span></span><br></pre></td></tr></table></figure></p><ul><li><code>hasOwnProperty()</code>方法可以检测一个属性是不是存在于实例，是则返回<code>true</code>。</li></ul><ul><li><p><code>in</code>操作符<br>（prop in obj）通过<code>in</code>操作符可以判定对象是否有该属性，不论是本身含有还是原型含有，都返回<code>true</code>。<br>可以通过<code>in</code>配合<code>hasOwnProperty()</code>确定该属性是存在于对象中还是原型中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectProperty</span>(<span class="params">obj, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name <span class="keyword">in</span> obj) &#123;</span><br><span class="line">obj.hasOwnProperty(name) ? <span class="string">'在对象中'</span> : <span class="string">'在原型中'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'不含有该属性'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ECMAScript 5</strong><code>Object.keys()</code>方法可以取得对象上所有可枚举的实例属性。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line">alert(keys); <span class="comment">//"name,age,job,sayName"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">"Rob"</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1);</span><br><span class="line">alert(p1keys); <span class="comment">//"name,age"</span></span><br></pre></td></tr></table></figure><ul><li><code>Object.getOwnPropertyNames</code>会得到所有实例属性，不论是否可枚举。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line">alert(keys); <span class="comment">//"constructor,name,age,job,sayName"</span></span><br></pre></td></tr></table></figure><p>简化<code>Person.prototype</code>写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">name : <span class="string">"Nicholas"</span>,</span><br><span class="line">age : <span class="number">29</span>,</span><br><span class="line">job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样写有一个缺陷，<code>constructor</code>属性则会等于<code>Object</code>，我们需要手动设置<code>constructor</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">name : "Nicholas",</span><br><span class="line">age : 29,</span><br><span class="line">job: "Software Engineer",</span><br><span class="line">sayName : function () &#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但这同时也会导致<code>constructor</code>的<code>[[Enumerable]]</code>特性变成了<code>true</code>，默认情况下是<code>false</code>。再修改下写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">name : <span class="string">"Nicholas"</span>,</span><br><span class="line">age : <span class="number">29</span>,</span><br><span class="line">job : <span class="string">"Software Engineer"</span>,</span><br><span class="line">sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">enumerable: <span class="literal">false</span>,</span><br><span class="line">value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>原型重写</strong>会导致构造函数与最初原型之间的联系切断。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;  <span class="comment">//重写</span></span><br><span class="line"><span class="keyword">constructor</span>: Person,</span><br><span class="line">name : "Nicholas",</span><br><span class="line">age : 29,</span><br><span class="line">job : "Software Engineer",</span><br><span class="line">sayName : function () &#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><br></p><h4 id="结合使用构造函数和原型模式"><a href="#结合使用构造函数和原型模式" class="headerlink" title="结合使用构造函数和原型模式"></a>结合使用构造函数和原型模式</h4><p>用构造函数模式定义实例属性，用原型模式定义方法和共享属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"><span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span> : Person,</span><br><span class="line">sayName : function()&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型的内部指针。</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a><code>instanceof</code>操作符</h5><p>用来确定原型和实例之间的关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>第二种方式就是<code>isPrototypeOf()</code>方法，只要原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>由于有声明提升的存在，定义函数不要放在条件表达式中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Yo'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<strong>ECMAScript</strong>中属于无效语法，在不同浏览器中修正的做法并不一致。推荐的写法，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Yo'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种函数表达式不存在声明提升，所以OK。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="函数作用域链"><a href="#函数作用域链" class="headerlink" title="函数作用域链"></a>函数作用域链</h4><p>当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用<code>arguments</code>和其他命名参数的值来初始化函数的活动对象。在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位…，直到作用域终点的全局执行环境。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：在闭包中使用<code>this</code>对象可能会导致一些问题。匿名函数的执行环境具有全局性，因此其<code>this</code>对象通常指向<code>window</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'The window'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">'my object'</span>,</span><br><span class="line">getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.nam;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getNameFunc()());  <span class="comment">// The Window (非严格模式)</span></span><br></pre></td></tr></table></figure></p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><hr><h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h3><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>抛开全局变量会成为<code>window</code>对象的属性不谈，定义全局变量与在<code>window</code>对象上直接定义属性还是有一点差别：<strong>全局变量不能通过<code>delete</code>操作符删除，而直接定义在<code>window</code>对象上的定义的属性可以</strong>。</p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>获得窗口左边和上边的位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure><br>Firefox支持<code>screenX</code>和<code>screenY</code>，其他浏览器均支持<code>screenLeft</code>、<code>screenTop</code>。</p><p>但是还是需要注意一个问题：在<code>IE</code> <code>Opera</code>中，<code>screenLeft  screenTop</code> 保存的的是可见区域的距离，也就是我们浏览器中不包含工具栏的区域与屏幕的距离；在<code>Chrome</code>、<code>Firefox</code>和<code>Safari</code>中<code>screenY</code>或<code>screenTop</code>返回的是整个浏览器窗口相对于屏幕坐标的值。</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>IE9+、Firefox、Safari、Opera和Chrome均提供了4个属性<code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code>和<code>outerHeight</code>。</p><ul><li>IE9+、Safari和Firefox中，<code>outerWidth</code>和<code>outerHeight</code>返回浏览器窗口本身的尺寸，而<code>innerWidth</code>和<code>innerHeight</code>则表示该容器中页面视图区的大小（减去边框宽度）</li><li>Chrome中，<code>inner*</code>和<code>outer*</code>返回相同的值，即视口大小而非浏览器窗口的大小。</li><li>在IE、Firefox、Safari、Opera和Chrome中，都能通过<code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>中保存了页面视口信息。</li></ul><p>获取页面视口大小<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">'number'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123; <span class="comment">// 浏览器标准模式</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// IE6 混杂模式</span></span><br><span class="line">pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">pageHeight = <span class="built_in">document</span>.doby.clientHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>resizeTo()</code>接受浏览器窗口的新宽度和新高度</li><li><code>resizeBy()</code>接受新窗口与原窗口的宽度和高度差。</li></ul><p>这两个方法可能被浏览器禁用。</p><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><p>如果是浏览器内置的屏蔽程序组织的弹出窗口，那么<code>window.open()</code>很可能会返回<code>null</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newWindow = <span class="built_in">window</span>.open(<span class="string">'https://www.google.com.hk'</span>, <span class="string">'_blank'</span>);</span><br><span class="line"><span class="keyword">if</span> (newWindow == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'The popup was blocked!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果是浏览器扩展或其他程序组织的弹出窗口，那么<code>window.open()</code>通常会抛出一个错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> newWindow = <span class="built_in">window</span>.open(<span class="string">'https://www.google.com.hk'</span>, <span class="string">'_blank'</span>);</span><br><span class="line"><span class="keyword">if</span> (newWindow == <span class="literal">null</span>) &#123;</span><br><span class="line">blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'The popup was blocked'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p><code>location</code>对象的属性</p><ul><li><code>hash</code></li><li><code>host</code></li><li><code>hostname</code>：与<code>host</code>不同的是，不带端口号</li><li><code>href</code></li><li><code>pathname</code>: 返回URL中的目录和（或）文件名</li><li><code>port</code></li><li><code>protocol</code></li><li><code>search</code>：返回URL的查询字符串，这个字符串<code>?</code>开头</li></ul><h3 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h3><p><code>location</code>对象的属性</p><ul><li><code>appCodeName</code>: 浏览器的名称，通常都是Mozilla</li><li><code>appMinorVersion</code>：此版本信息</li><li><code>appName</code>: 完整的浏览器名称</li><li><code>appVersion</code>：浏览器的版本</li><li><code>buildID</code>：浏览器编译版本</li><li><code>cookieEnabled</code>：表示<code>cookie</code>是否可用</li><li><code>cpuClass</code>：客户端计算机中使用的CPU类型</li><li><code>javaEnabled()</code>：表示当前浏览器中是否启用了java</li><li><code>language</code>: 浏览器的主语言</li><li><code>mimeTypes</code>：浏览器中注册的MIME类型数组</li><li><code>onLine</code>：表示浏览器是都连接到因特网</li><li><code>oscpu</code>：客户端计算机的操作系统或使用的CPU</li><li><code>platform</code>：浏览器所在的系统平台</li><li><code>plugins</code>：浏览器中安装的插件信息的数组</li><li><code>preference()</code>：设置用户的首选项</li><li><code>systemLanguage</code>：操作系统的语言</li><li><code>userAgent</code>：浏览器的用户代理字符串</li></ul><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><hr><h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><h4 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h4><p>每个节点都有一个<code>nodeType</code>属性，用于表明节点的类型。</p><ul><li><code>Node.ELEMENT_NODE(1)</code></li><li><code>Node.ATTRIBUTE_NODE(2)</code></li><li><code>Node.TEXT_NODE(3)</code></li><li><code>Node.CDATA_SECTION_NODE(4)</code></li><li><code>Node.ENTITY_REFERENCE_NODE(5)</code></li><li><code>Node.ENTITY_NODE(6)</code></li><li><code>Node.PROCESSING_INSTRUCTION_NODE(7)</code></li><li><code>Node.COMMENT_NODE(8)</code></li><li><code>Node.DOCUMENT_NODE(9)</code></li><li><code>Node.DOCUMENT_TYPE_NODE(10)</code></li><li><code>Node.DOCUMENT_FRAGMENT_NODE(11)</code></li><li><code>Node.NOTATION_NODE(12)</code></li></ul><p>为了确保跨浏览器兼容，将<code>nodeType</code>属性与数字值进行比较：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Node is an element'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>nodeName</code>属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> value = someNode.nodeName;  <span class="comment">// nodeName的值是元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><ul><li><code>childNodes</code>属性</li></ul><p>每个节点都有一个<code>childNodes</code>属性，其中保存着一个<code>NodeList</code>对象，该对象是一种类数组对象。</p><ul><li><code>parentNode</code>属性</li></ul><p>每个节点都有一个<code>parentNode</code>属性，该属性指向文档树中的父节点。包含在<code>childNodes</code>列表中的每个节点相互都是兄弟节点。使用<code>previousSibling</code>和<code>nextSibling</code>属性，可以访问其他兄弟节点。</p><p><strong>注</strong>：列表中第一个节点的<code>previousSibling</code>属性值为<code>null</code>，同理列表中最后一个节点的<code>nextSibling</code>属性也是<code>null</code>。父节点的<code>firstChild</code>和<code>lastChild</code>属性分别指向其<code>childNodes</code>列表中的第一个和最后一个节点。如果不存在则为<code>null</code>。</p><p><code>hasChildNodes()</code>方法在节点包含一个或多个子节点的情况下返回<code>true</code>，比查询<code>childNodes.length</code>更简便。</p><p>最后一个属性<code>ownerDocument</code>，该属性指向表示整个文档的文档节点（root），直接返回根节点不需要一层层向上回溯。</p><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul><li><code>appendChild()</code></li></ul><p>用于向<code>childNodes</code>列表的末尾添加一个节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br><span class="line">alert(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>任何DOM节点不可能同时出现在多个位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(someNode.firstChild);</span><br><span class="line">alert(returnedNode == someNode.firstChild); <span class="comment">//false</span></span><br><span class="line">alert(returnedNode == someNode.lastChild); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><ul><li><code>insertBefore()</code></li></ul><p>把节点放在指定位置，该方法接受两个参数：要插入的节点和作为参考的节点。插入节点后，被插入的节点会变成参照节点的前一个兄弟节点。参照节点是<code>null</code>的话，<code>insertBefore</code>与<code>appendChild</code>执行相同的操作，都插入列表末尾。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入后成为最后一个子节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>);</span><br><span class="line">alert(newNode == someNode.lastChild); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入后成为第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.insertBefore(newNode, someNode.firstChild);</span><br><span class="line">alert(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line">alert(newNode == someNode.firstChild); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild);</span><br><span class="line">alert(newNode == someNode.childNodes[someNode.childNodes.length<span class="number">-2</span>]); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><ul><li><code>replaceChild()</code></li></ul><p>替换节点，接受两个参数：要插入的节点和要替换的节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild);</span><br></pre></td></tr></table></figure></p><ul><li><code>removeChild()</code></li></ul><p>移除节点，接受一个参数：要被移除的节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerFirstChild = someNode.removeChild(someNode.firstChild);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除最后一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerLastChild = someNode.removeChild(someNode.lastChild);</span><br></pre></td></tr></table></figure></p><ul><li><code>cloneNode()</code></li></ul><p>复制节点，接受一个布尔值，表示是否深复制。复制后返回的节点没有父节点，可以通过插入等操作手动指定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepList = myList.cloneNode(<span class="literal">true</span>);</span><br><span class="line">alert(deepList.childNodes.length); <span class="comment">//3（IE &lt; 9）或7（其他浏览器）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shallowList = myList.cloneNode(<span class="literal">false</span>);</span><br><span class="line">alert(shallowList.childNodes.length); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><br><strong>注</strong>：<code>cloneNode</code>方法不会复制DOM节点的<code>js</code>属性。IE存在一个bug，它会复制事件处理程序。</p><ul><li><code>normalize()</code></li></ul><p>稍后讨论</p><p>以上方法的返回值，都是被操作的节点。</p><h4 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h4><p><code>Document</code>节点具有下列特征：</p><ul><li><code>nodeType</code>的值为9</li><li><code>nodeName</code>的值为<code>#document</code></li><li><code>nodeValue</code>的值为<code>null</code></li><li><code>parentNode</code>的值为<code>null</code></li><li><code>ownerDocument</code>的值为<code>null</code></li><li>其子节点可能是一个<code>DocumentType</code>（最多一个）、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code>或<code>Comment</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过`documentElement`属性访问&lt;html&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="comment">// 访问 &lt;body&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="comment">// &lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype;</span><br><span class="line"><span class="comment">// &lt;title&gt;</span></span><br><span class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="comment">// 完整 url</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL;</span><br><span class="line"><span class="comment">// domain 域名</span></span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain;</span><br><span class="line"><span class="comment">// 取得来源页面的URL(也就是导航到这页的页面)</span></span><br><span class="line"><span class="keyword">var</span> referrer = <span class="built_in">document</span>.referrer;</span><br></pre></td></tr></table></figure><p>查找元素的方法：</p><ul><li><code>document.getElementById()</code></li><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementsByName()</code></li></ul><p>文档写入：</p><ul><li><code>document.write()</code></li><li><code>document.writeln()</code>在字符串尾加换行符(\n)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;script type=\"text/javascript\" src=\"file.js\"&gt;"</span> + <span class="string">"&lt;\/script&gt;"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h4><p><code>Element</code>类型提供了对元素标签名、子节点及特性的访问。</p><ul><li><code>nodeType</code>的值为1</li><li><code>nodeName</code>的值为元素的标签名</li><li><code>nodeValue</code>的值为<code>null</code></li><li><code>parentNode</code>可能是<code>Document</code>或<code>Element</code></li><li>其子节点可能是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code>或<code>EntityReference</code></li></ul><p>访问元素的标签名，可以使用<code>nodeName</code>属性，也可以使用<code>tagName</code>属性，后者更直观。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"myDiv"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var div = document.getElementById("myDiv");</span></span><br><span class="line"><span class="regexp">alert(div.tagName); /</span><span class="regexp">/"DIV"</span></span><br><span class="line"><span class="regexp">alert(div.tagName == div.nodeName); /</span><span class="regexp">/true</span></span><br></pre></td></tr></table></figure><br>操作特性的方法：</p><ul><li><code>getAttribute()</code></li><li><code>setAttribute()</code></li><li><code>removeAttribute()</code></li></ul><p><code>attributes</code>属性</p><p><code>Element</code>类型是使用<code>attributes</code>属性的唯一一个DOM节点属性。<code>attributes</code>属性包含一个<code>NamedNodeMap</code>。元素的每一个特性都由一个<code>Attr</code>节点表示，每个节点都保存在<code>NamedNodeMap</code>对象中。</p><p><code>NamedNodeMap</code>对象的方法：</p><ul><li><code>getNamedItem(name)</code>：返回<code>nodeName</code>属性等于<code>name</code>的节点</li><li><code>removeNamedItem(name)</code>：从列表中移除<code>nodeName</code>属性等于<code>name</code>的节点</li><li><code>setNamedItem(node)</code>：向列表中添加节点，以节点的<code>nodeName</code>属性为索引</li><li><code>item(pos)</code>：返回位于数字<code>pos</code>位置处的节点</li></ul><p><code>attributes</code>属性中包含一系列节点，每个节点的<code>nodeName</code>就是特性的名称，而节点<code>nodeValue</code>就是特性的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">'id'</span>).nodeValue;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes[<span class="string">'id'</span>].nodeValue;</span><br></pre></td></tr></table></figure></p><p>创建元素<br><code>document.createElement()</code>方法可以创建新元素，这个方法接受一个参数（标签名）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><p>文本节点由<code>Text</code>类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。</p><ul><li><code>nodeType</code>的值为3</li><li><code>nodeName</code>的值为<code>#text</code></li><li><code>nodeValue</code>的值为节点所包含的文本</li><li><code>parentNode</code>是一个<code>Element</code></li></ul><p>操作节点中的文本：</p><ul><li><code>appendData(text)</code>：将<code>text</code>添加到节点的末尾</li><li><code>deleteData(offset, count)</code>：从<code>offset</code>指定的位置开始删除<code>count</code>个字符</li><li><code>insertData(offset, text)</code>：在<code>offset</code>指定的位置插入<code>text</code></li><li><code>replaceData(offset, count, text)</code>：用<code>text</code>替换从<code>offset</code>指定的位置开始到<code>offset+count</code>为止的文本</li><li><code>splitText(offset)</code>：从<code>offset</code>指定的位置将当前文本分成两个文本节点</li><li><code>substringData(offset, count)</code>：提取从<code>offset</code>指定的位置开始到<code>offset+count</code>为止处的字符串。</li></ul><p>在向DOM文档中插入文本之前，应该先对其进行<code>HTML</code>编码</p><p>创建文本节点</p><ul><li><code>document.createTextNode()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt; world!"</span>);</span><br></pre></td></tr></table></figure><h3 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h3><p>使用函数实现加载外部<code>JS</code>文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">script.src = url;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScirpt(<span class="string">'xx.js'</span>);</span><br></pre></td></tr></table></figure><br>IE将<code>&lt;script&gt;</code>视为一个特殊的元素，不允许DOM访问其子节点。不过可以使用<code>&lt;script&gt;</code>元素的<code>text</code>属性指定<code>JS</code>代码。</p><h4 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create table</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">'100%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create tbody</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create row1</span></span><br><span class="line"><span class="keyword">var</span> row1 = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span><br><span class="line">tbody.appendChild(row1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell1_1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell1_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 1,1'</span>));</span><br><span class="line">row1.appendChild(cell1_1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell2_1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell2_1.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 2,1'</span>));</span><br><span class="line">row1.appendChild(cell2_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create row2</span></span><br><span class="line"><span class="keyword">var</span> row2 = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span><br><span class="line">tbody.appendChild(row2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell1_2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell1_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 1,2'</span>));</span><br><span class="line">row1.appendChild(cell1_2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell2_2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line">cell2_2.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Cell 2,2'</span>));</span><br><span class="line">row1.appendChild(cell2_2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br></pre></td></tr></table></figure><h2 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h2><hr><h3 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h3><ul><li><code>querySelector()</code>方法</li></ul><p><code>querySelector()</code>方法接受一个<strong>CSS</strong>选择符，返回与该模式匹配的<strong>第一个元素</strong>，若没有，返回<code>null</code>。</p><p>可以通过<code>Document</code>类型调用，也可以通过<code>Element</code>类型调用，后者只会在该元素后代元素的范围内查找匹配的元素。</p><ul><li><code>querySelectorAll()</code>方法</li></ul><p><code>querySelectorAll()</code>方法返回的是所有匹配的元素，是一个<code>NodeList</code>实例。</p><ul><li><code>matchesSelector()</code>方法</li></ul><p>为<code>Element</code>类型新增的一个方法，接受一个参数<code>CSS</code>选择符，如果调用元素与该选择符匹配，返回<code>true</code>，否则返回<code>false</code>。</p><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><ul><li><code>childElementCount</code>：返回子元素（不包含文本节点和注释）的个数</li><li><code>firstElementChild</code>：指向第一个子元素</li><li><code>lastElementChild</code>：指向最后一个子元素</li><li><code>previousElementSibling</code>：指向前一个兄弟元素</li><li><code>nextElementSibling</code>：指向后一个兄弟元素</li></ul><p>不同于前面的返回<strong>节点</strong>的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点版本</span></span><br><span class="line"><span class="keyword">var</span> i,</span><br><span class="line">len,</span><br><span class="line">child = element.firstChild;</span><br><span class="line"><span class="keyword">while</span>(child != element.lastChild)&#123;</span><br><span class="line"><span class="keyword">if</span> (child.nodeType == <span class="number">1</span>)&#123; <span class="comment">//检查是不是元素</span></span><br><span class="line">processChild(child);</span><br><span class="line">&#125;</span><br><span class="line">child = child.nextSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素版本</span></span><br><span class="line"><span class="keyword">var</span> i,</span><br><span class="line">len,</span><br><span class="line">child = element.firstElementChild;</span><br><span class="line"><span class="keyword">while</span>(child != element.lastElementChild)&#123;</span><br><span class="line">processChild(child); <span class="comment">//已知其是元素</span></span><br><span class="line">child = child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><ul><li><code>getElementsByClassName()</code>方法</li><li><code>classList</code>属性，这个属性是新集合类型<code>DOMTokenList</code>的实例。<ul><li><code>add(value)</code></li><li><code>contains(value)</code></li><li><code>remove(value)</code></li><li><code>toggle(value)</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(&quot;user&quot;);</span><br></pre></td></tr></table></figure><h4 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h4><p><code>document.activeElement</code>属性，始终会引用DOM中前端获得了焦点的元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line">button.focus();</span><br><span class="line">alert(<span class="built_in">document</span>.activeElement === button); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br><code>document.hasFocus()</code>方法，可以确定文档是否获得了焦点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line">button.focus();</span><br><span class="line">alert(<span class="built_in">document</span>.hasFocus()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h4 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a><code>HTMLDocument</code>的变化</h4><pre><code>+ `readyState`属性有两个值，`loading`和`complete`</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line"><span class="comment">// 加载完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="document-charset字符集属性"><a href="#document-charset字符集属性" class="headerlink" title="document.charset字符集属性"></a><code>document.charset</code>字符集属性</h4><h4 id="data-自定义数据属性"><a href="#data-自定义数据属性" class="headerlink" title="data-自定义数据属性"></a><code>data-</code>自定义数据属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"myDiv"</span> data-appId=<span class="string">"12345"</span> data-myname=<span class="string">"Nicholas"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var div = document.getElementById("myDiv");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/取得自定义属性的值</span></span><br><span class="line"><span class="regexp">var appId = div.dataset.appId;</span></span><br><span class="line"><span class="regexp">var myName = div.dataset.myname;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/设置值</span></span><br><span class="line"><span class="regexp">div.dataset.appId = 23456;</span></span><br><span class="line"><span class="regexp">div.dataset.myname = "Michael";</span></span><br></pre></td></tr></table></figure><h4 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a><code>innerHTML</code>属性</h4><p>在读模式下，<code>innerHTML</code> 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应<br>的HTML 标记。在写模式下，<code>innerHTML</code> 会根据指定的值创建新的DOM树，然后用这个DOM树完全<br>替换调用元素原先的所有子节点</p><h4 id="outerHTML属性"><a href="#outerHTML属性" class="headerlink" title="outerHTML属性"></a><code>outerHTML</code>属性</h4><p>在读模式下，<code>outerHTML</code> 返回调用它的元素及所有子节点的HTML 标签。在写模式下，<code>outerHTML</code><br>会根据指定的HTML 字符串创建新的DOM 子树，然后用这个DOM子树完全替换调用元素。</p><h4 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a><code>insertAdjacentHTML()</code>方法</h4><p>插入元素的新增方法，接受两个参数，插入的位置和要插入的HTML文本，第一个参数的值：</p><ul><li><code>&#39;beforebegin&#39;</code></li><li><code>&#39;afterbegin&#39;</code></li><li><code>&#39;beforeend&#39;</code></li><li><code>&#39;afterend&#39;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为前一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"beforebegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为第一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"afterbegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为最后一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为后一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"afterend"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br></pre></td></tr></table></figure><h4 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView()方法"></a><code>scrollIntoView()</code>方法</h4><p><code>scrollIntoView</code>方法可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。如果这个方法传入<code>true</code>作为参数，或者不传参数，那么窗口滚动之后就会让调用元素的顶部与视口顶部 尽可能平齐，如果传入<code>false</code>，调用元素会尽可能全部出现在视口中，不过顶部不一定平齐。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让元素可见</span></span><br><span class="line"><span class="built_in">document</span>.form[<span class="number">0</span>].scrollIntoView();</span><br></pre></td></tr></table></figure></p><h3 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h3><h4 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h4><ul><li><code>innerText</code>属性</li><li><code>outerText</code>属性</li></ul><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><ul><li><code>scrollIntoViewIfNeeded(alignCenter)</code>：只有在当前元素不可见的情况下，才滚动浏览器或窗口或容器元素最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。</li><li><code>scrollByLines(lineCount)</code>：将元素的内容滚动指定的行高，<code>lineCount</code>值可以是正值，也可以是负值。</li><li><code>scrollByPages(pageCount)</code>：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。</li></ul><p><code>scrollIntoView()</code>和<code>scrollIntoViewIfNeeded()</code>的作用对象是元素的容器，而<code>scrollByLines()</code>和<code>scrollByPages()</code>影响的则是元素自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在当前元素不可见的时候，让它进入浏览器的视口</span></span><br><span class="line"><span class="built_in">document</span>.images[<span class="number">0</span>].scrollIntoViewIfNeeded();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将页面主体往回滚动1 页</span></span><br><span class="line"><span class="built_in">document</span>.body.scrollByPages(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h2 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h2><hr><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><ul><li><code>offsetHeight</code>：元素在垂直方向上占用的空间大小。包括元素的高度，（可见的）水平滚动条的高度，上边框高度和下边框高度</li><li><code>offsetWidth</code>：元素在水平方向上占用的空间大小。包括元素的宽度，（可见的）垂直滚动条的宽度，左边框宽度和右边框宽度</li><li><code>offsetLeft</code>：元素的左外边框至包含元素的左内边框之间的像素距离。</li><li><code>offsetTop</code>：元素的上外边框至包含元素的上内边框之间的像素距离。</li></ul><p>其中，<code>offsetLeft</code>和<code>offsetTop</code>属性与包含元素有关，包含元素的引用保存在<code>offsetParent</code>属性中。<code>offsetParent</code>属性不一定与<code>parentNode</code>的值相等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素上偏移</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> actualLeft = ele.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> current = ele.offsetParent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">actualLeft += current.offsetLeft;</span><br><span class="line">current = current.offsetParent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素左偏移同理</span></span><br></pre></td></tr></table></figure><br>一般来说，页面中所有的元素都被包含在几个<code>&lt;div&gt;</code>元素中，而这些<code>&lt;div&gt;</code>元素的<code>offsetParent</code>又是<code>&lt;body&gt;</code>元素，所以<code>getElementLeft()</code>与<code>getElementTop()</code>会返回与<code>offsetLeft</code>和<code>offsetTop</code>相同的值。</p><h4 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h4><ul><li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度</li><li><code>clientHeight</code>: 元素内容区高度加上上下内边距高度</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;  <span class="comment">// IE7之前</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">width: <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">height: <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h4><p><strong>滚动大小</strong>，指的是包含滚动内容的元素的大小。有些元素（<code>&lt;html&gt;</code>），即使没有执行任何代码也能自动添加滚动条；但另外一些元素，则需要通过<strong>CSS</strong>的<code>overflow</code>属性设置才能滚动。</p><ul><li><code>scrollHeight</code>：在没有滚动条的情况下，元素内容的总高度</li><li><code>scrollWidth</code>：在没有滚动条的情况下，元素内容的总宽度</li><li><code>scrollLeft</code>：被隐藏在内容区域左侧的像素数，通过设置这个属性可以改变元素的滚动位置</li><li><code>scrollTop</code>：被隐藏在内容区域上方的像素数，通过设置这个属性可以改变元素的滚动位置</li></ul><p><code>scrollWidth</code>和<code>scrollHeight</code>主要用于确定元素内容的实际大小。</p><p><code>scrollWidth</code> 和<code>scrollHeight</code> 与<code>clientWidth</code> 和<code>clientHeight</code> 之间的关系？</p><ul><li><strong>Firefox</strong>中这两组属性始终相等，但大小代表的是文档内容区域的实际尺寸，非视口尺寸</li><li><strong>Opera Safari Chrome</strong>中这两组属性有区别，其中<code>scrollWidth</code> 和<code>scrollHeight</code> 等于视口大小，而<code>clientWidth</code> 和<code>clientHeight</code> 等于文档内容区域的大小。</li><li><strong>IE（在标准模式）</strong>中的这两组属性不相等，其中<code>scrollWidth</code> 和<code>scrollHeight</code> 等于文档内容区域的大小，而<code>clientWidth</code> 和<code>clientHeight</code> 等于视口大小。</li></ul><p>通过<code>scrollLeft</code> 和<code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么<code>scrollTop</code> 的值会大于0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么<code>scrollLeft</code> 的值会大于0，且表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元素的<code>scrollLeft</code> 和<code>scrollTop</code> 设置为0，就可以重置元素的滚动位置。下面这个函数会检测元素是否位于顶部，如果不是就将其回滚到顶部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollToTop</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.scrollTop != <span class="number">0</span>)&#123;</span><br><span class="line">element.scrollTop = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="确定元素大小"><a href="#确定元素大小" class="headerlink" title="确定元素大小"></a>确定元素大小</h4><ul><li><code>getBoundingClientRect()</code>方法，会返回一个矩形对象，包含<code>left top right bottom</code>四个属性。这些属性给出了元素在页面中相对于视口的位置。</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><p>可以使用<code>document.createNodeIterator()</code>方法创建它的新实例，接受4个参数。</p><ul><li><code>root</code>：想要作为搜索起点的树中的节点</li><li><code>whatToShow</code>：表示要访问哪些节点的数字代码</li><li><code>filter</code>：是一个<code>NodeFilter</code>对象，或者一个表示应该接受还是拒绝某种特定节点的函数</li><li><code>entityReferenceExpansion</code>：布尔值，表示是否要扩展实体引用。</li></ul><p><code>whatToShow</code>这个参数的值以常量形式在<code>NodeFilter</code>类型中定义：</p><ul><li><code>NodeFilter.SHOW_ALL</code></li><li><code>NodeFilter.SHOW_ELEMENT</code></li><li><code>NodeFilter.SHOW_ATTRIBUTE</code></li><li><code>NodeFilter.SHOW_TEXT</code></li><li><code>NodeFilter.SHOW_CDATA_SECTION</code></li><li><code>NodeFilter.SHOW_ENTITY_REFERENCE</code></li><li><code>NodeFilter.SHOW_ENTITYE</code></li><li><code>NodeFilter.SHOW_PROCESSING_INSTRUCTION</code></li><li><code>NodeFilter.SHOW_COMMENT</code></li><li><code>NodeFilter.SHOW_DOCUMENT</code></li><li><code>NodeFilter.SHOW_DOCUMENT_TYPE</code></li><li><code>NodeFilter.SHOW_DOCUMENT_FRAGMENT</code></li><li><code>NodeFilter.SHOW_NOTATION</code></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><hr><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>IE的事件流叫做<strong>事件冒泡</strong>，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>Netscape 团队提出的事件流叫做<strong>事件捕获</strong>，事件捕获的用意在于在事件到达预定目标之前捕获它。</p><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>“DOM2级事件”规定的事件流包括三个阶段：<code>事件捕获阶段</code>、<code>处于目标阶段</code>和<code>事件冒泡阶段</code>。</p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><h4 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h4><p>每个元素（包括<code>window</code>和<code>document</code>）都有自己的事件处理程序，这些属性通常全部小写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>DOM 0级方法指定的事件处理程序被认为是元素的方法，因此，这个时候的事件处理程序是在元素的作用域中运行，也就是说程序中的<code>this</code>可以引用当前元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.id);  <span class="comment">// 'myBtn'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以这种方式添加的事件处理程序会在事件流的<strong>冒泡阶段</strong>被处理。</p><h4 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h4><ul><li><code>addEventListener()</code></li><li><code>removeEventListener()</code></li></ul><p>定义了两个方法用于处理指定和删除事件处理程序的操作。所有的DOM节点中都包含这两个方法，接受三个参数：<strong>事件名</strong>、<strong>事件处理程序</strong>和<strong>布尔值</strong>。最后这个布尔值如果是<code>true</code>，表示在捕获阶段调用事件处理程序；<code>false</code>表示在冒泡阶段调用事件处理程序，默认是<code>false</code>。</p><p>通过<code>addEventListener()</code>添加的事件处理程序只能使用<code>removeEventListener()</code>来移除。如果通过<code>addEventListener()</code>添加的匿名函数将无法移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&#39;click&#39;, function () &#123;  &#x2F;&#x2F;匿名函数</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>：大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段（<code>false</code>），这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。</p><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><ul><li><code>attachEvent()</code></li><li><code>detachEvent()</code></li></ul><p>这两个方法接受两个参数：事件名（带<code>on</code>）和事件处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn &#x3D; document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;, function()&#123;</span><br><span class="line">alert(&quot;Clicked&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><strong>注</strong>：在IE 中使用<code>attachEvent()</code>与使用DOM0 级方法的主要区别在于事件处理程序的作用域。</p><ul><li>DOM0 级作用域是其所属元素</li><li><code>attachEvent()</code>方法的作用域是全局（<code>this === window</code>）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn &#x3D; document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;, function()&#123;</span><br><span class="line">alert(&quot;Clicked&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;, function()&#123;</span><br><span class="line">alert(&quot;Hello world!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注</strong>：与DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。单击这个例子中的按钮，首先看到的是”Hello world!”，然后才是”Clicked”。</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>在触发DOM上的某个事件时，会产生一个事件对象<code>event</code>。</p><h4 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h4><p><code>event</code>对象成员</p><table><thead><tr><th>属性/方法</th><th>类型</th><th>读/写</th><th>说明</th></tr></thead><tbody><tr><td><code>bubbles</code></td><td><code>Boolean</code></td><td>只读</td><td>表明事件是否冒泡</td></tr><tr><td><code>cancelable</code></td><td><code>Boolean</code></td><td>只读</td><td>表明是否可以取消事件的默认行为</td></tr><tr><td><code>currentTarget</code></td><td><code>Element</code></td><td>只读</td><td>其事件处理程序当前正在处理事件的那个元素</td></tr><tr><td><code>defaultPrevented</code></td><td><code>Boolean</code></td><td>只读</td><td>为<code>true</code>表示已经调用<code>preventDefault()</code></td></tr><tr><td><code>detail</code></td><td><code>Integer</code></td><td>只读</td><td>与事件相关的细节信息</td></tr><tr><td><code>eventPhase</code></td><td><code>Integer</code></td><td>只读</td><td>调用事件处理程序的阶段：1 捕获，2 处于目标，3 冒泡</td></tr><tr><td><code>preventDefault()</code></td><td><code>Function</code></td><td>只读</td><td>取消事件的默认行为。如果<code>cancelable</code> 是<code>true</code>，则可以使用这个方法</td></tr><tr><td><code>stopImmediatePropagation()</code></td><td><code>Function</code></td><td>只读</td><td>取消事件的进一步冒泡或捕获，同时阻止任何事件处理程序被调用</td></tr><tr><td><code>stopPropagation()</code></td><td><code>Function</code></td><td>只读</td><td>取消事件的进一步捕获或冒泡。如果<code>bubbles</code>为<code>true</code>，则可以使用这个方法</td></tr><tr><td><code>target</code></td><td><code>Element</code></td><td>只读</td><td>事件的目标</td></tr><tr><td><code>trusted</code></td><td><code>Boolean</code></td><td>只读</td><td>为<code>true</code>表示事件是浏览器生成，<code>false</code>是开发人员创建</td></tr><tr><td><code>type</code></td><td><code>String</code></td><td>只读</td><td>被触发的事件类型</td></tr><tr><td><code>view</code></td><td><code>AbstractView</code></td><td>只读</td><td>与事件关联的抽象视图。等同于发生事件的<code>window</code>对象</td></tr></tbody></table><p>在事件处理程序内部，对象<code>this</code> 始终等于<code>currentTarget</code> 的值，而<code>target</code> 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则<code>this</code>、<code>currentTarget</code> 和<code>target</code> 包含相同的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">alert(event.currentTarget === <span class="built_in">document</span>.body); <span class="comment">//true</span></span><br><span class="line">alert(<span class="keyword">this</span> === <span class="built_in">document</span>.body); <span class="comment">//true</span></span><br><span class="line">alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>)); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>调用<code>event</code>方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">event.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line"><span class="comment">//省略的代码</span></span><br><span class="line">&#125;,</span><br><span class="line">getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">&#125;,</span><br><span class="line">getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">&#125;,</span><br><span class="line">preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event.preventDefault)&#123;</span><br><span class="line">event.preventDefault();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line"><span class="comment">//省略的代码</span></span><br><span class="line">&#125;,</span><br><span class="line">stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event.stopPropagation)&#123;</span><br><span class="line">event.stopPropagation();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h4 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h4><ul><li><code>load</code>事件</li><li><code>unload</code>事件</li><li><code>resize</code>事件</li><li><code>scroll</code>事件</li></ul><h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><ul><li><code>blur</code>事件：失去焦点</li><li><code>focus</code>事件：获得焦点</li></ul><h4 id="鼠标与滚动事件"><a href="#鼠标与滚动事件" class="headerlink" title="鼠标与滚动事件"></a>鼠标与滚动事件</h4><ul><li><code>click</code>事件</li><li><code>dbclick</code>事件</li><li><code>mousedown</code>事件：按下鼠标</li><li><code>mouseenter</code>事件：光标移入</li><li><code>mouseleave</code>事件：光标移出</li><li><code>mousemove</code>事件：鼠标在元素内部移动重复触发</li><li><code>mouseout</code>事件：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素</li><li><code>mouseover</code>事件：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发</li><li><code>mouseup</code>事件：释放鼠标按钮时触发</li></ul><p>页面上的所有元素都支持鼠标事件。除了<code>mouseenter</code> 和<code>mouseleave</code>，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。</p><p>只有在同一个元素上相继触发<code>mousedown</code> 和<code>mouseup</code> 事件，才会触发<code>click</code> 事件；如果<code>mousedown</code> 或<code>mouseup</code> 中的一个被取消，就不会触发<code>click</code> 事件。</p><h4 id="触摸设备"><a href="#触摸设备" class="headerlink" title="触摸设备"></a>触摸设备</h4><p>iOS和Android设备的相关事件：</p><ul><li>不支持<code>dbclick</code>事件。双击浏览器窗口会放大画面</li><li>轻击可单击元素会触发<code>mousemove</code>事件。。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生<code>mousedown</code>、<code>mouseup</code> 和<code>click</code> 事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了<code>onclick</code> 事件处理程序的元素。</li><li><code>mousemove</code>事件也会触发<code>mouseover</code>和<code>mouseout</code>事件</li><li>两个手指放在屏幕上且页面随手指移动而滚动时会触发<code>mousewheel</code>和<code>scroll</code>事件。</li></ul><h4 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h4><ul><li><code>contextmenu</code>事件</li><li><code>beforeunload</code>事件</li><li><code>DOMContentLoaded</code>事件</li><li><code>readystatechange</code>事件<ul><li><code>uninitialized</code>未初始化</li><li><code>loading</code></li><li><code>loaded</code></li><li><code>interactive</code>:可以操作对象，但还没有完全加载</li><li><code>complete</code></li></ul></li><li><code>hashchange</code>事件</li></ul><h4 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h4><ul><li><code>orientationchange</code>事件：横竖屏，有三个值： -90 ，0， 90</li></ul><h4 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h4><ul><li>触摸事件<ul><li><code>touchstart</code></li><li><code>touchmove</code></li><li><code>touchend</code></li><li><code>touchcancel</code></li></ul></li><li>手势事件<ul><li><code>gesturestart</code></li><li><code>gesturechange</code></li><li><code>gestureend</code></li></ul></li></ul><h3 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h3><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>例如在<code>&lt;ul&gt;</code>为添加一个<code>click</code>事件，所有<code>&lt;li&gt;</code>子元素点击事件都会冒泡到<code>&lt;ul&gt;</code>上。</p><h2 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h2><hr><h3 id="表单基础知识"><a href="#表单基础知识" class="headerlink" title="表单基础知识"></a>表单基础知识</h3><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"reset"</span> value=<span class="string">"Reset Form"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h4><p>每个表单都有<code>elements</code>属性，该属性是表单中所有表单元素的集合。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"form1"</span>);</span><br><span class="line"><span class="comment">//取得表单中的第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field1 = form.elements[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//取得名为"textbox1"的字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">"textbox1"</span>];</span><br><span class="line"><span class="comment">//取得表单中包含的字段的数量</span></span><br><span class="line"><span class="keyword">var</span> fieldCount = form.elements.length;</span><br></pre></td></tr></table></figure></p><h3 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h3><h4 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h4><p>屏蔽特定的字符，需要检测<code>keypress</code>事件对应的字符编码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">'keypress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">event = EventUtil.getEvent(event);</span><br><span class="line"><span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"><span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(charCode))) &#123;</span><br><span class="line">EventUtil.preventDefault(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="HTML5约束验证API"><a href="#HTML5约束验证API" class="headerlink" title="HTML5约束验证API"></a>HTML5约束验证API</h4><h5 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h5><p>HTML5为文本字段新增了<code>pattern</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> pattern=<span class="string">"\d+"</span> name=<span class="string">"count"</span>&gt;</span><br></pre></td></tr></table></figure></p><h5 id="检测有效性"><a href="#检测有效性" class="headerlink" title="检测有效性"></a>检测有效性</h5><p>使用<code>checkValidity()</code>方法可以检测表单中的某个字段是否有效。是否有效的判断依据是一些<code>&lt;input&gt;</code>的约束条件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>].checkValidity())&#123;</span><br><span class="line"><span class="comment">//字段有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//字段无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也可以检测整个表单是否有效<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.forms[<span class="number">0</span>].checkValidity())&#123;</span><br><span class="line"><span class="comment">//表单有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//表单无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="禁用验证"><a href="#禁用验证" class="headerlink" title="禁用验证"></a>禁用验证</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"signup.php"</span> novalidate&gt;</span><br><span class="line">&lt;!--这里插入表单元素--&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML5-脚本编程"><a href="#HTML5-脚本编程" class="headerlink" title="HTML5 脚本编程"></a>HTML5 脚本编程</h2><hr><h3 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h3><p><strong>跨文档消息传送</strong>（cross-document messaging）简称XDM。其核心方法是<code>postMessage()</code>方法。</p><p><code>postMessage()</code>方法接受两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：所有支持XDM的浏览器也支持iframe的`contentWindow`属性</span></span><br><span class="line"><span class="keyword">var</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">'myframe'</span>).contentWindow;</span><br><span class="line">iframeWindow.postMessage(<span class="string">'A secret'</span>, <span class="string">'https://yeasoenzhang.github.io'</span>);</span><br></pre></td></tr></table></figure><br>尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于<code>https://yeasonzhang.github.io</code>域。</p><p>接收到<strong>XDM</strong>消息时，会触发<code>window</code>对象的<code>message</code>事件，这个事件是以异步形式触发。<br>传递的<code>onmessage</code>处理程序的事件对象包含三个重要信息：</p><ul><li><code>data</code>：作为<code>postMessage()</code>第一个参数传入的字符串数据</li><li><code>origin</code>：发送消息的文档所在的域。</li><li><code>source</code>：发送消息的文档的<code>window</code>对象的代理。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="comment">//确保发送消息的域是已知的域</span></span><br><span class="line"><span class="keyword">if</span> (event.origin == <span class="string">"https://yeasonzhang.github.io"</span>)&#123;</span><br><span class="line"><span class="comment">//处理接收到的数据</span></span><br><span class="line">processMessage(event.data);</span><br><span class="line"><span class="comment">//可选：向来源窗口发送回执</span></span><br><span class="line">event.source.postMessage(<span class="string">"Received!"</span>, <span class="string">"http://p2p.wrox.com"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>XDM 还有一些怪异之处。首先，<code>postMessage()</code>的第一个参数最早是作为“永远都是字符串”来实现的。但后来这个参数的定义改了，改成允许传入任何数据结构。可是，并非所有浏览器都实现了这一变化。为保险起见，使用<code>postMessage()</code>时，最好还是只传字符串。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用<code>JSON.stringify()</code>，通过<code>postMessage()</code>传入得到的字符串，然后再在<code>onmessage</code> 事件处理程序中调用<code>JSON.parse()</code>。</p><h3 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h3><h4 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h4><p>拖动某个元素时，将依次触发的事件：</p><ul><li><code>dragstart</code></li><li><code>drag</code></li><li><code>dragend</code></li></ul><p>当某个元素被拖动到一个有效的放置目标时，会依次触发下列事件：</p><ul><li><code>dragenter</code></li><li><code>dragover</code></li><li><code>dragleave</code>（离开）或<code>drag</code>（放进去了）</li></ul><h4 id="dataTransfer对象"><a href="#dataTransfer对象" class="headerlink" title="dataTransfer对象"></a>dataTransfer对象</h4><p><code>dataTransfer</code>对象，它是事件对象的一个属性，用于被拖动元素向放置目标传递<strong>字符串格式</strong>的数据。该对象有两个主要方法:</p><ul><li><code>getData()</code></li><li><code>setData()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置和接收文本数据</span><br><span class="line">event.dataTransfer.setData(&quot;text&quot;, &quot;some text&quot;);</span><br><span class="line">var text &#x3D; event.dataTransfer.getData(&quot;text&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置和接收URL</span><br><span class="line">event.dataTransfer.setData(&quot;URL&quot;, &quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;);</span><br><span class="line">var url &#x3D; event.dataTransfer.getData(&quot;URL&quot;);</span><br></pre></td></tr></table></figure>不过，保存在<code>dataTransfer</code>对象中的数据只能在<code>drap</code>事件处理程序中读取。如果在<code>ondrop</code> 处理程序中没有读到数据，那就是<code>dataTransfer</code> 对象已经被销毁，数据也丢失了。</li></ul><h4 id="drapEffect-与-effectAllowed"><a href="#drapEffect-与-effectAllowed" class="headerlink" title="drapEffect 与 effectAllowed"></a>drapEffect 与 effectAllowed</h4><p><code>dateTransfer</code>对象有两个属性：</p><ul><li><code>dropEffect</code></li><li><code>effectAllowed</code></li></ul><p><code>dropEffect</code>，属性可以知道被拖动的元素能够执行那种放置行为。</p><ul><li><code>none</code>：不能放在这里</li><li><code>move</code>：应该把拖放的元素移动到放置目标</li><li><code>copy</code>：应该把拖动的元素复制到放置目标</li><li><code>link</code>：表示放置目标会打开拖动的元素</li></ul><p>要使用<code>dropEffect</code>属性，必须在<code>ondragenter</code>事件处理程序中针对放置目标来设置。</p><p><code>effectAllowed</code>属性表示允许拖动元素的哪种<code>dropEffect</code>。</p><ul><li><code>uninitialized</code>：没有给被拖动的元素放置任何放置行为</li><li><code>none</code>：被拖动的元素不能有任何行为</li><li><code>copy</code>：只允许值为<code>copy</code>的<code>dropEffect</code></li><li><code>link</code>：只允许值为<code>link</code>的<code>dropEffect</code></li><li><code>move</code>：只允许值为<code>move</code>的<code>dropEffect</code></li><li><code>copyLink</code>：允许值为<code>copy</code>和<code>link</code>的<code>dropEffect</code></li><li><code>copyMove</code>：允许值为<code>copy</code>和<code>move</code>的<code>dropEffect</code></li><li><code>linkMove</code>：允许值为<code>link</code>和<code>move</code>的<code>dropEffect</code></li><li><code>all</code>: 允许任意<code>dropEffect</code></li></ul><p>必须在<code>ondragstart</code> 事件处理程序中设置<code>effectAllowed</code> 属性。</p><h4 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h4><p>HTML5为所有元素规定了<code>draggable</code>属性，表示元素是否可以拖动。只有图像和链接的<code>draggable</code>默认是<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 让这个图像不可以拖动 --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;smile.gif&quot; draggable&#x3D;&quot;false&quot; alt&#x3D;&quot;Smiley face&quot;&gt;</span><br><span class="line">&lt;!-- 让这个元素可以拖动 --&gt;</span><br><span class="line">&lt;div draggable&#x3D;&quot;true&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="其他成员"><a href="#其他成员" class="headerlink" title="其他成员"></a>其他成员</h4><p>HTML5规定了<code>dateTransfer</code>对象还应该包含下列方法和属性。</p><ul><li><code>addElement(element)</code></li><li><code>clearData(format)</code></li><li><code>setDragImage(element, x, y)</code></li><li><code>type</code></li></ul><h2 id="错误处理与调试"><a href="#错误处理与调试" class="headerlink" title="错误处理与调试"></a>错误处理与调试</h2><hr><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 可能出错的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="comment">// 处理发生的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h5><p>只要代码中包含<code>finially</code>子句，无论<code>try</code>还是<code>catch</code>语句中的<code>return</code>语句都将被忽略。</p><h5 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h5><ul><li><code>Error</code></li><li><code>EvalError</code></li><li><code>RangeError</code></li><li><code>ReferenceError</code></li><li><code>SyntaxError</code></li><li><code>TypeError</code></li><li><code>URIError</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">someFunction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h4><p>与<code>try-catch</code> 语句相配的还有一个<code>throw</code> 操作符，用于随时抛出自定义错误。抛出错误时，必须要给<code>throw</code> 操作符指定一个值，这个值是什么类型，没有要求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="attr">name</span>: <span class="string">"JavaScript"</span>&#125;;</span><br></pre></td></tr></table></figure><br>遇到<code>throw</code>操作符时，代码会立即停止执行。只有当<code>try-catch</code>语句捕获到被抛出值，代码才会继续执行</p><h5 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h5><p>可以利用原型链通过继承<code>Error</code>创建自定义错误类型。需要为新创建的错误类型指定<code>name</code>和<code>message</code>属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'CustomError'</span>;</span><br><span class="line"><span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">'Error msg'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="Error事件"><a href="#Error事件" class="headerlink" title="Error事件"></a>Error事件</h4><p>任何没有通过<code>try-catch</code>处理的错误都会触发<code>window</code>对象的<code>error</code>事件。</p><p>在任何Web浏览器中，<code>onerror</code>事件处理程序都不会创建<code>event</code>对象，但它可以接受三个参数：错误消息、错误所在的URL和行号。</p><p>要指定onerror 事件处理程序，必须使用如下所示的DOM0 级技术，它没有遵循“DOM2 级事件”的标准格式（<code>addEventListener</code>）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line</span>)</span>&#123;</span><br><span class="line">alert(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>只要发生错误，无论是不是浏览器生成的，都会触发<code>error</code>事件，然后让浏览器的默认机制发挥作用，这时候我们需要阻止浏览器的默认行为（<code>return false</code>）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line">retrun <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="常见的错误类型"><a href="#常见的错误类型" class="headerlink" title="常见的错误类型"></a>常见的错误类型</h4><ul><li>类型转换错误</li><li>数据类型错误</li><li>通信错误</li></ul><p>在数据检测的时候，基本类型的值应该使用<code>typeof</code>来检测，对象的值应该使用<code>instanceof</code>。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><hr><h3 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h3><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p><code>JSON</code>对象有两个方法：<code>stringify</code>和<code>parse()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">authors: [</span><br><span class="line"><span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">],</span><br><span class="line">edition: <span class="number">3</span>,</span><br><span class="line">year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br></pre></td></tr></table></figure><br>以上就把<code>Javascript</code>对象序列化为一个<code>JSON</code>字符串（没有空格和缩进）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011&#125;</span><br></pre></td></tr></table></figure><br>如果传给<code>JSON.parse()</code>的字符串不是有效的<code>JSON</code>，会抛出错误。</p><h4 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h4><p><code>JSON.stringify()</code>除了要序列化的<code>JS</code>对象外，还可以接受两个参数，一个是过滤器（数组或函数），第二个参数是一个选项，表示是都在<code>JSON</code>字符串中保留缩进。</p><h5 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line"><span class="string">"authors"</span>: [</span><br><span class="line"><span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">],</span><br><span class="line">edition: <span class="number">3</span>,</span><br><span class="line">year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">"title"</span>, <span class="string">"edition"</span>]);</span><br></pre></td></tr></table></figure><p>第二个参数中包含两个字符串<code>&quot;title&quot;, &quot;edition&quot;</code>，所以只会返回对应的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3&#125;</span><br></pre></td></tr></table></figure><br>过滤器为函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line"><span class="string">"authors"</span>: [</span><br><span class="line"><span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">],</span><br><span class="line">edition: <span class="number">3</span>,</span><br><span class="line">year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(key)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line"><span class="keyword">return</span> value.join(<span class="string">","</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"year"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"edition"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><strong>注</strong>：返回<code>undefined</code>删除该属性，上例的<code>edition</code>属性就会被删除。</p><h5 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h5><p><code>JSON.stringify()</code>方法的第三个参数用于控制结果中的缩进和空白符。可以是数字，表示缩进的空格数；也可以是字符串，将该字符串作为缩进的表示。</p><h5 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON()方法"></a><code>toJSON()</code>方法</h5><h4 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h4><p><code>JSON.parse()</code>方法也可以接受第二参数，该参数是一个函数（被称为还原函数），传入函数的参数均为<code>key, value</code>。</p><p>如果还原函数返回<code>undefined</code>，则表示要从结果中删除响应的键。</p><h2 id="Ajax与Comet"><a href="#Ajax与Comet" class="headerlink" title="Ajax与Comet"></a>Ajax与Comet</h2><hr><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><h4 id="XHR的用法"><a href="#XHR的用法" class="headerlink" title="XHR的用法"></a>XHR的用法</h4><ul><li><code>open(&#39;method&#39;, &#39;url&#39;, bool)</code>：第三个参数表示是否异步发送</li><li><code>send()</code>：接受一个参数作为请求主体发送的数据，如果不需要则传入<code>null</code></li></ul><p><code>XHR</code>对象的属性</p><ul><li><code>responseText</code>：作为相应主体被返回的文本</li><li><code>responseXML</code>：如果相应的内容类型是<code>&quot;text/xml&quot;</code>或<code>&quot;application/xml&quot;</code>，这个属性中将包含这响应数据的XML DOM文档</li><li><code>status</code>：响应的HTTP状态</li><li><code>statusText</code>：HTTP状态的说明</li></ul><p>同步请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">alert(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>readyState</code>：表示请求/响应过程的阶段<ul><li>0：未初始化，尚未调用<code>open()</code>方法</li><li>1：启动，调用了<code>open()</code>方法，尚未调用<code>send()</code>方法</li><li>2：发送，调用了<code>send()</code>方法，尚未接收到响应。</li><li>3：接收，接收到部分响应数据</li><li>4：完成，已经接收到全部响应数据</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">alert(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li><code>abort()</code>：在接收到响应之前通过该方法取消异步请求。<br>建议调用这个方法之后，对<code>XHR</code>对象进行解引用操作。</li></ul><h4 id="HTTP-头部信息"><a href="#HTTP-头部信息" class="headerlink" title="HTTP 头部信息"></a>HTTP 头部信息</h4><p>默认情况下，在发送<code>XHR</code>请求的同时，还会发送下列头部信息：</p><ul><li><code>Accept</code>：浏览器能够处理的内容类型</li><li><code>Accept-Charset</code>：浏览器能够显示的字符集</li><li><code>Accept-Encoding</code>：浏览器能够处理的压缩编码</li><li><code>Accept-Language</code>：浏览器当前设置的语言</li><li><code>Connection</code>：浏览器与服务器之间连接的类型</li><li><code>Cookie</code>： 当前页面的 Cookie</li><li><code>Host</code>：发出请求的页面所在的域</li><li><code>Referer</code>：发出请求的页面的URI</li><li><code>User-Agent</code>：浏览器的用户代理</li></ul><p>自定义请求头部信息，使用<code>setRequestHeader()</code>方法，该方法接受两个参数：头部字段的名称和头部字段的值。</p><p>要成功发送请求头部信息，必须在调用<code>open()</code>方法之后且调用<code>send()</code>方法之前调用<code>serRequestHeader()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"MyHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br><strong>注</strong>建议使用自定义的头部字段名称，不要使用浏览器正常发送的字段名称，否则有可能会影响服务器的响应。有的浏览器允许开发人员重写默认的头部信息，但有的浏览器则不允许这样做。</p><p>调用<code>XHR</code>对象的<code>getResponseHeader()</code>方法，接受一个参数：头部字段名称。就能取得相应的响应头部信息。<br>调用<code>getAllResponseHeaders()</code>方法可以取得包含所有头部信息的字符串。</p><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>使用<code>GET</code>请求经常会发生一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用<code>encodeURIComponent()</code>进行编码，然后才能放到URL的末尾。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>) </span>&#123;</span><br><span class="line">url += (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>);</span><br><span class="line">url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"example.php"</span>;</span><br><span class="line"><span class="comment">//添加参数</span></span><br><span class="line">url = addURLParam(url, <span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">url = addURLParam(url, <span class="string">"book"</span>, <span class="string">"Professional JavaScript"</span>);</span><br><span class="line"><span class="comment">//初始化请求</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, url, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>如果我们希望用XHR模仿表单提交，需要将<code>Content-Type</code>头部信息设置为<code>application/x-www-form-urlencoded</code>(表单提交的内容类型)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">alert(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"postexample.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line">xhr.send(serialize(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h3><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p><code>FormData</code>为序列化表单以及创建于表单格式相同的数据提供了便利。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'Yeaseon'</span>);</span><br></pre></td></tr></table></figure><br><code>append</code>方法可以将表单的字段和值，传入<code>FormData</code>对象中。也可以预先填入表单中的字段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.form[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><br><code>FormData</code>的方便就在于不必手动修改XHR对象的请求头部。</p><h4 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h4><p><code>XHR</code>对象添加了一个<code>timeout</code>属性，表示请求在等待多少毫秒之后终止。如果规定时间内浏览器没有收到响应，就会触发<code>timeout</code>事件，进而调用<code>ontimeout</code>事件处理程序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"timeout.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.timeout = <span class="number">1000</span>; <span class="comment">//将超时设置为1 秒钟</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Request did not return in a second."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br>超时之后请求终止，但是此时的<code>readyState</code>可能已经变为了<code>4</code>，就意味着会调用<code>onreadystatechange</code>事件。</p><p>可是，如果在超时终止请求之后再访问<code>status</code> 属性，就会导致错误。为避免浏览器报告错误，可以将检查<code>status</code> 属性的语句封装在一个<code>try-catch</code>语句当中。</p><h4 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType()方法"></a>overrideMimeType()方法</h4><p>用于重写<code>XHR</code>响应的<code>MIME</code>类型。因为返回响应的<code>MIME</code> 类型决定了<code>XHR</code> 对象如何处理它，所以提供一种方法能够重写服务器返回的<code>MIME</code> 类型是很有用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"text.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.overrideMimeType(<span class="string">"text/xml"</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p>有以下6个进度事件：</p><ul><li><code>loadstart</code>：在接收到响应数据的第一个字节触发</li><li><code>progress</code>：在接收响应期间持续不断地触发</li><li><code>error</code>：在请求发生错误时触发</li><li><code>abort</code>：在因为调用<code>abort()</code>方法而终止连接时触发</li><li><code>load</code>：在接收到完整的响应数据时触发</li><li><code>loadend</code>：在通信完成或者触发<code>error</code>、<code>abort</code>，或<code>load</code>事件后触发</li></ul><p><strong>progress</strong>事件<br><code>onprogress</code>事件处理程序会接收到一个<code>event</code>对象，<code>target</code>属性指向<code>XHR</code>对象，包含着三个额外的属性：</p><ul><li><code>lengthComputable</code>：表示进度信息是否可用的布尔值</li><li><code>position</code>：表示已经接受的字节数</li><li><code>totalSize</code>：表示根据<code>Content-Length</code>响应头部确定的预期字节数。</li></ul><h3 id="跨资源共享"><a href="#跨资源共享" class="headerlink" title="跨资源共享"></a>跨资源共享</h3><h4 id="IE对CORS的实现"><a href="#IE对CORS的实现" class="headerlink" title="IE对CORS的实现"></a>IE对CORS的实现</h4><p>微软在IE8中引入了<code>XDR</code>类型，类似与<code>XHR</code>对象，两者的不同之处：</p><ul><li>cookie不会随请求发送，也不会随响应返回</li><li>只能设置请求头部信息中的<code>Content-Type</code>字段</li><li>不能访问响应头部信息</li><li>只支持<code>GET</code>和<code>POST</code>请求</li></ul><p>请求返回之后，就会触发<code>load</code>事件，响应数据也会保存在<code>responseText</code>属性中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(xdr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"An error occurred."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://..../xxx/'</span>);</span><br><span class="line">xdr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br>在请求返回之前可以调用<code>abort()</code>方法终止请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdr.abort();</span><br></pre></td></tr></table></figure><br><code>XDR</code>对象也支持<code>timeout</code>属性以及<code>ontimeout</code>事件处理程序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(xdr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"An error occurred."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.timeout = <span class="number">1000</span>;</span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Request took too long."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>);</span><br><span class="line">xdr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br>为了支持<code>POST</code>请求，<code>XDR</code>对象提供了<code>contentType</code>属性，用来表示发送数据的格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xdr &#x3D; new XDomainRequest();</span><br><span class="line">xdr.onload &#x3D; function () &#123;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror &#x3D; function () &#123;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(&#39;post&#39;, &#39;http:&#x2F;&#x2F;www.somewhere-else.com&#x2F;page&#x2F;&#39;);</span><br><span class="line">xdr.contentType &#x3D; &#39;application&#x2F;x-www-form-urlencoded&#39;;</span><br><span class="line">xdr.send(&#39;name1&#x3D;value1&amp;name2&#x3D;value2&#39;);</span><br></pre></td></tr></table></figure></p><h4 id="其他浏览器对CORS的实现"><a href="#其他浏览器对CORS的实现" class="headerlink" title="其他浏览器对CORS的实现"></a>其他浏览器对CORS的实现</h4><p>与IE中的<code>XDR</code>对象不同，通过跨域<code>XHR</code>对象可以访问<code>status</code>和<code>statusText</code>属性，并且支持同步请求。同时也有一些限制：</p><ul><li>不能使用<code>setRequestHeader()</code>设置自定义头部</li><li>不能发送和接收<code>cookie</code></li><li>调用<code>getAllResponseHeaders()</code>方法总会返回空字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">alert(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h3><h4 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">"http://www.example.com/test?name=Nicholas"</span>;</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><code>JSONP</code>是<strong>JSON with padding</strong>的简写。<code>JSONP</code>只不过时被包含在函数调用中的<code>JSON</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>: <span class="string">"Yeaseon"</span>&#125;);</span><br></pre></td></tr></table></figure><br><code>JSONP</code>由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是请求中指定的。下面是一个经典的<code>JSONP</code>请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;freegeoip.net&#x2F;json&#x2F;?callback&#x3D;handleResponse</span><br></pre></td></tr></table></figure><br>这里指定的回调函数的名字叫做<code>handleResponse</code>。</p><p><code>JSONP</code>是通过动态<code>&lt;script&gt;</code>元素来使用的，使用时可以为<code>src</code>属性指定一个跨域<code>URL</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"You’re at IP address "</span> + response.ip + <span class="string">", which is in "</span> +</span><br><span class="line">response.city + <span class="string">", "</span> + response.region_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"http://freegeoip.net/json/?callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure><h4 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h4><p><strong>SSE</strong>支持短轮询、长轮训和HTTP流，而且能在断开连接时自动确定何时重新连接。</p><h5 id="SSE-API"><a href="#SSE-API" class="headerlink" title="SSE API"></a>SSE API</h5><p>要预订新的事件流，首先要创建一个新的<code>EventSource</code>对象，并传入一个入口点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'myevents.php'</span>);</span><br></pre></td></tr></table></figure><br>传入的URL必须与创建对象的页面同源。<br><code>EventSource</code>的实例有一个<code>readyState</code>属性：<code>0</code>表示正连接到服务器，<code>1</code>表示打开了连接，<code>2</code>表示关闭了连接。<br><code>EventSource</code>实例还有三个事件：</p><ul><li><code>open</code>：在建立连接时触发</li><li><code>message</code>：在从服务器接收到新事件时触发</li><li><code>error</code>：在无法建立连接时触发</li></ul><p>服务器发回的数据以字符串形式保存在<code>event.data</code>中。<br>默认情况下，<code>EventSource</code>对象会保持与服务器的活动连接。如果想强制立即断开连接并且不在重新连接，可以调用<code>close()</code>方法。</p><h4 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h4><p>由于 Web Sockets 使用了自定义的协议,所以 URL 模式也略有不同。未加密的连接不再是 http:// ,而是 ws:// ;加密的连接也不是 https:// ,而是 wss:// 。</p><h5 id="Web-Sockets-API"><a href="#Web-Sockets-API" class="headerlink" title="Web Sockets API"></a>Web Sockets API</h5><p>创建一个WebSockets实例对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br></pre></td></tr></table></figure><br>WebSocket也有一个表示当前状态的<code>readyState</code>属性：</p><ul><li><code>WebSocket.OPENING (0)</code> ：正在建立连接</li><li><code>WebSocket.OPEN (1)</code>：已经建立连接</li><li><code>WebSocket.CLOSING (2)</code>：正在关闭连接</li><li><code>WebSocket.CLOSE (3)</code>：已经关闭连接</li></ul><h5 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h5><p>向服务器发送数据，使用<code>send()</code>方法并传入任意字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws:// www.example.com/server.php'</span>);</span><br><span class="line">socket.send(<span class="string">'Hello World'</span>);</span><br></pre></td></tr></table></figure><br>Web Sockets只能发送纯文本数据，对于复杂的数据结构，在发送之前，必须进行序列化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">time: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">text: <span class="string">'Hello world'</span>,</span><br><span class="line">clientId: <span class="string">'adfalsf39'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.send(<span class="built_in">JSON</span>.stringify(message));</span><br></pre></td></tr></table></figure><br>当服务器向客户端发来消息时，WebSocket对象就会触发<code>message</code>事件。这个<code>message</code>事件与其他传递消息的协议类似，也是把返回的数据保存在<code>event.data</code>属性中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> data = event.data;</span><br><span class="line"> <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与<code>send()</code>类似，<code>event.data</code>中返回的数据也是字符串，需要手工解析这些数据。</p><h5 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h5><p>WebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发：</p><ul><li><code>open</code>：在成功建立连接时触发</li><li><code>error</code>：在发生错误时触发，连接不能持续</li><li><code>close</code>：在连接关闭时触发</li></ul><p>WebSocked对象不支持DOM 2级事件监听：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Connection established."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Connection error."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><hr><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>用于区分原生和非原生<strong>JavaScript</strong>对象，通过<code>Object.prototype.toString()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object Function]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRegExp</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object RegExp]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><p>防止构造函数内<code>this</code>指针的指向被改变（指向<code>window</code>）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>, <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">i,len;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line"><span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line"><span class="comment">//跳过</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种改法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObjext != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">'string'</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>, <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">i,len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; len = versions.length; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line"><span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// skip</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No XHR object available.'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createXHR();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第二种改法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createXHR = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">'undefined'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObjext != <span class="string">'undefined'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">'string'</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>, <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">i,len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; len = versions.length; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line"><span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// skip</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No XHR object available.'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p><code>bind()</code>函数，语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="离线应用与客户端存储"><a href="#离线应用与客户端存储" class="headerlink" title="离线应用与客户端存储"></a>离线应用与客户端存储</h2><hr><h3 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h3><p><code>navigator.onLine</code>属性可以判断设备否能访问网络。</p><p>HTML5定义两个事件：<code>online</code>和<code>offline</code>，当网络状态变化时，分别触发这两个事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'online'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'online'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'offline'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h4 id="Web存储机制"><a href="#Web存储机制" class="headerlink" title="Web存储机制"></a>Web存储机制</h4><p>Web Storage规范包含两种对象的定义：<code>sessionStorage</code>和<code>globalStorage</code>。这两个对象在支持的浏览器中都是以<code>windows</code>对象属性的形式存在。</p><h5 id="Storage类型"><a href="#Storage类型" class="headerlink" title="Storage类型"></a><code>Storage</code>类型</h5><p><code>Storage</code>类型提供最大的存储空间来存储名值对。</p><ul><li><code>clear()</code>：删除所有值</li><li><code>getItem(name)</code>：根据指定的名字<code>name</code>获取对应的值</li><li><code>key(index)</code>：获得<code>index</code>位置处的值的名字</li><li><code>removeItem(name)</code>：删除由<code>name</code>指定的名值对</li><li><code>setItem(name, value)</code>：为指定的<code>name</code>设置一个对应的值</li></ul><h5 id="sessionStorage对象"><a href="#sessionStorage对象" class="headerlink" title="sessionStorage对象"></a><code>sessionStorage</code>对象</h5><p><code>sessionStorage</code>对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。存储在<code>sessionStorage</code>中的数据可以跨越页面刷新而存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法存储数据</span></span><br><span class="line">sessionStorage.setItem(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="comment">//使用属性存储数据</span></span><br><span class="line">sessionStorage.book = <span class="string">"Professional JavaScript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//使用属性读取数据</span></span><br><span class="line"><span class="keyword">var</span> book = sessionStorage.book;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用delete 删除一个值——在WebKit 中无效</span></span><br><span class="line"><span class="keyword">delete</span> sessionStorage.name;</span><br><span class="line"><span class="comment">//使用方法删除一个值</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">"book"</span>);</span><br></pre></td></tr></table></figure><br>可以通过结合<code>length</code>属性和<code>key()</code>方法来迭代<code>sessionStorage</code>中的值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = sessionStorage.length; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> key = sessionStorage.key(i);</span><br><span class="line"><span class="keyword">var</span> value = sessionStorage.getItem(key);</span><br><span class="line"><span class="built_in">console</span>.log(key + <span class="string">' = '</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还可以使用<code>for-in</code>循环来迭代<code>sessionStorage</code>中的值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> sessionStorage) &#123;</span><br><span class="line"><span class="keyword">var</span> value = sessionStorage.getItem(key);</span><br><span class="line"><span class="built_in">console</span>.log(key + <span class="string">' = '</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="globalStorage对象"><a href="#globalStorage对象" class="headerlink" title="globalStorage对象"></a><code>globalStorage</code>对象</h5><p>这个对象的目的是跨越会话存储数据，，但有特定的访问限制。要使用<code>globalStorage</code>，首先要指定哪些域可以访问该数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">globalStorage[<span class="string">'wrox.com'</span>].name = <span class="string">'Yeaseon'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">var</span> name = globalStorage[<span class="string">'wrox.com'</span>].name;</span><br></pre></td></tr></table></figure><br>上例，访问的是针对域名<code>wrox.com</code>的存储空间。<code>globalStorage</code>对象不是<code>Storage</code>的实例，<br>而具体的<code>globalStorage[&#39;wrox.com&#39;]</code>才是。这个存储空间对于<code>wrox.com</code>及其所有子域都是可以访问的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">globalStorage[<span class="string">"www.wrox.com"</span>].name = <span class="string">"Yeaseon"</span>;</span><br><span class="line">globalStorage[<span class="string">"www.wrox.com"</span>].book = <span class="string">"Professional JavaScript"</span>;</span><br><span class="line">globalStorage[<span class="string">"www.wrox.com"</span>].removeItem(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">var</span> book = globalStorage[<span class="string">"www.wrox.com"</span>].getItem(<span class="string">"book"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="localStorage对象"><a href="#localStorage对象" class="headerlink" title="localStorage对象"></a><code>localStorage</code>对象</h5><p><code>localStorage</code>对象是HTML5规范中作为持久保存客户端数据的方案，并且取代<code>globalStorage</code>。要访问同一个<code>localStorage</code>对象，页面必须来自同一个域名（子域名无效），必须同源。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法存储数据</span></span><br><span class="line">localStorage.setItem(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="comment">//使用属性存储数据</span></span><br><span class="line">localStorage.book = <span class="string">"Professional JavaScript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> name = localStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//使用属性读取数据</span></span><br><span class="line"><span class="keyword">var</span> book = localStorage.book;</span><br></pre></td></tr></table></figure></p><h5 id="storage事件"><a href="#storage事件" class="headerlink" title="storage事件"></a><code>storage</code>事件</h5><p>对<code>Storage</code>对象进行任何修改，都会在文档上触发<code>storage</code>事件。这个事件的<code>event</code>对象有以下属性。</p><ul><li><code>domain</code>：发生变化的存储空间的域名</li><li><code>key</code>：设置或删除的键名</li><li><code>newValue</code>：如果是设置值，则是新值；如果是删除键，则是<code>null</code></li><li><code>oldValue</code>：键被更改之前的值</li></ul><p>在这四个属性中，IE8 和Firefox 只实现了<code>domain</code> 属性。在撰写本书的时候，WebKit 尚不支持<br><code>storage</code> 事件</p><h4 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><p>Indexed Database API，简称<strong>IndexedDB</strong>，是在浏览器中保存结构化数据的一种数据库。<strong>IndexedDB</strong>设计的操作完全是异步进行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.msIndexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.webkitIndexedDB;</span><br></pre></td></tr></table></figure></p><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p><strong>IndexedDB</strong>就是一个数据库，它最大的特色就是使用对象保存数据，而不是使用表来保存数据。</p><p><code>indexDB.open()</code>，传入一个数据库参数。如果该数据库存在就会发送一个打开它的请求；如果该数据库不存在，就会发送一个创建并打开它的请求。请求会返回一个<code>IDBRequest</code>对象，这个对象上可以添加<code>onerror</code>和<code>onsuccess</code>事件处理程序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request, database;</span><br><span class="line"></span><br><span class="line">request = indexedDB.open(<span class="string">'admin'</span>);</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(event.target.errorCode);</span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">database = event.target.result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>event.target</code>都指向<code>request</code>对象，因此他们可以互换使用。<br>发生错误了，<code>event.target.errorCode</code>中将会保存一个错误码：</p><ul><li><code>IDBDatebaseException.UNKNOWN_ERR(1)</code>：意外错误</li><li><code>IDBDatebaseException.NON_TRANSIENT_ERR(2)</code>：操作不合法</li><li><code>IDBDatebaseException.NOT_FOUND_ERR(3)</code>：未发现要操作的数据库</li><li><code>IDBDatebaseException.CONSTRAINT_ERR(4)</code>：违反了数据库约束</li><li><code>IDBDatebaseException.DATA_ERR(5)</code>：提供给事务的数据不能满足要求</li><li><code>IDBDatebaseException.NOT_ALLOWED_ERR(6)</code>：操作不合法</li><li><code>IDBDatebaseException.TRANSACTION_INACTIVE_ERR(7)</code>：试图重用已完成的事务</li><li><code>IDBDatebaseException.ABORT_ERR(8)</code>：请求中断</li><li><code>IDBDatebaseException.READ_ONLY_ERR(9)</code>：试图在只读模式下写入或修改数据</li><li><code>IDBDatebaseException.TIMEOUT_ERR(10)</code>：在有效时间内未完成操作</li><li><code>IDBDatebaseException.QUOTA_ERR(11)</code>：磁盘空间不足</li></ul><p>指定数据库版本号，通过<code>setVersion()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (database.version != <span class="string">'1.0'</span>) &#123;</span><br><span class="line">request = database.setVersion(<span class="string">'1.0'</span>)；</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(event.target.errorCode);</span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span>Database name: <span class="string">' + database.name + '</span>, <span class="attr">Version</span>: <span class="string">' + database.version);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">console.log('</span><span class="string">'Database name: '</span> + database.name + <span class="string">', Version: '</span> + database.version);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h5><p>假设要保存的用户记录由用户名、密码等组成，那么保存一条记录的对象应该类似：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">username: <span class="string">'007'</span>,</span><br><span class="line">firstname: <span class="string">'James'</span>,</span><br><span class="line">lastname: <span class="string">'Bond'</span>,</span><br><span class="line">password: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果使用<code>username</code>属性作为这个对象存储空间的键，这个<code>username</code>必须全局唯一，而且大部分时候都要通过这个键来访问数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = db.createObjectStore(<span class="string">'users'</span>, &#123; <span class="attr">keyPath</span>: <span class="string">'username'</span> &#125;);</span><br></pre></td></tr></table></figure><br>其中第二个参数中的<code>keyPath</code>属性，就是空间中将要保存的对象的一个属性，而这个属性将作为存储空间的键来使用。</p><p>通过<code>add()</code>或<code>put()</code>方法来向存储空间添加数据。着两个方法都接收一个参数，就是要保存的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//users 中保存着一批用户对象</span></span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>,</span><br><span class="line">request,</span><br><span class="line">requests = [],</span><br><span class="line">len = users.length;</span><br><span class="line"><span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">request = store.add(users[i++]);</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//处理错误</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//处理成功</span></span><br><span class="line">&#125;;</span><br><span class="line">requests.push(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>在数据库对象上调用<code>transaction()</code>可以创建事务，任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事务</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction();</span><br></pre></td></tr></table></figure><br>可以传入要访问的一或多个对象存储空间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction(<span class="string">'users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction([<span class="string">'users'</span>, <span class="string">'anotherStore'</span>]);</span><br></pre></td></tr></table></figure><br>前面这些事务都是以<strong>只读</strong>方式访问数据。要修改访问方式，必须在创建事务时传入第二个参数，这个参数表示访问模式：</p><ul><li><code>IDBTransaction.READ_ONLY(0)</code>：只读</li><li><code>IDBTransaction.READ_WRITE(1)</code>：读写</li><li><code>IDBTransaction.VERSION_CHANGE(2)</code>：改变</li></ul><p>在Chrome中叫做<code>webkitIDBTransaction</code>，可以使用一下代码兼容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDBTransaction = <span class="built_in">window</span>.IDBTransaction || <span class="built_in">window</span>.webkitIDBTransaction;</span><br></pre></td></tr></table></figure><br>这样就能方便的指定<code>transaction()</code>第二个参数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction(<span class="string">'users'</span>, IDBTransaction.READ_WRITE);</span><br></pre></td></tr></table></figure></p><p>取得事务的索引后，使用<code>objectStore()</code>方法并传入存储空间的名称，就可以访问指定的存储空间。然后通过如下方法操作对象：</p><ul><li><code>add()</code></li><li><code>put()</code></li><li><code>get()</code></li><li><code>delete()</code></li><li><code>clear()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = db.transaction(<span class="string">'users'</span>).objectStore(<span class="string">'users'</span>).get(<span class="string">'007'</span>);</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Did not get the object!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = event.target.result;</span><br><span class="line"><span class="built_in">console</span>.log(result.firstName);  <span class="comment">// 'James'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以针对事务对象本身进行事件处理，存在两个事件<code>onerror</code>，<code>oncomplete</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 整个事务都被取消了</span></span><br><span class="line">&#125;</span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 整个事务都成功完成了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>注</strong>：在<code>oncomplete</code>事件的事件对象中访问不到<code>get()</code>请求返回的数据，必须在<code>onsuccess</code>事件中处理。</p><h5 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDBKeyRange = <span class="built_in">window</span>.IDBKeyRange || <span class="built_in">window</span>.webkitIDBKeyRange;</span><br></pre></td></tr></table></figure><p>有四种定义键范围的方法：</p><ul><li><code>only()</code>：取得指定对象的键</li><li><code>lowerBound()</code>：指定结果集的下界</li><li><code>upperBound()</code>：指定结果集的上界</li><li><code>bound()</code>：同时指定上、下界</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var onlyRange &#x3D; IDBKeyRange.only(&quot;007&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从键为&quot;007&quot;的对象开始，然后可以移动到最后</span><br><span class="line">var lowerRange &#x3D; IDBKeyRange.lowerBound(&quot;007&quot;);</span><br><span class="line">&#x2F;&#x2F;从键为&quot;007&quot;的对象的下一个对象开始，然后可以移动到最后</span><br><span class="line">var lowerRange &#x3D; IDBKeyRange.lowerBound(&quot;007&quot;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从头开始，到键为&quot;ace&quot;的对象为止</span><br><span class="line">var upperRange &#x3D; IDBKeyRange.upperBound(&quot;ace&quot;);</span><br><span class="line">&#x2F;&#x2F;从头开始，到键为&quot;ace&quot;的对象的上一个对象为止</span><br><span class="line">var upperRange &#x3D; IDBKeyRange.upperBound(&quot;ace&quot;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从键为&quot;007&quot;的对象开始，到键为&quot;ace&quot;的对象为止</span><br><span class="line">var boundRange &#x3D; IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;);</span><br><span class="line">&#x2F;&#x2F;从键为&quot;007&quot;的对象的下一个对象开始，到键为&quot;ace&quot;的对象为止</span><br><span class="line">var boundRange &#x3D; IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, true);</span><br><span class="line">&#x2F;&#x2F;从键为&quot;007&quot;的对象的下一个对象开始，到键为&quot;ace&quot;的对象的上一个对象为止</span><br><span class="line">var boundRange &#x3D; IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, true, true);</span><br><span class="line">&#x2F;&#x2F;从键为&quot;007&quot;的对象开始，到键为&quot;ace&quot;的对象的上一个对象为止</span><br><span class="line">var boundRange &#x3D; IDBKeyRange.bound(&quot;007&quot;, &quot;ace&quot;, false, true);</span><br></pre></td></tr></table></figure><h2 id="新型的API"><a href="#新型的API" class="headerlink" title="新型的API"></a>新型的API</h2><hr><h3 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h3><p>Page Visibility API 是为了让开发人员知道页面是否对用户可见推出的。</p><ul><li><code>document.hidden</code>：表示页面是否隐藏的布尔值。</li><li><code>document.visibilityState</code><ul><li>页面在后台标签页中或浏览器最小化</li><li>页面在前台标签页中</li><li>实际的页面已经隐藏，但用户可以看到页面的预览</li><li>页面在屏幕外执行预渲染处理</li></ul></li><li><code>visibilitychange</code>事件：当文档可见性发生改变时，触发该事件。</li></ul><h3 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h3><p>Geolocation API 在浏览器中的实现是<code>navigator.geolocation</code>对象。</p><ul><li><code>getCurrentPosition()</code></li></ul><p>调用这个方法就会触发请求用户共享地理定位信息的对话框。这个方法接收三个参数：成功回调，可选的失败回调和可选的选项对象。</p><p><code>成功回调</code>会接收到一个<code>Position</code>对象参数，该对象有两个属性:<code>coords</code>和<code>timestamp</code>。</p><p><code>coords</code>对象中包含于位置相关的信息：</p><ul><li><code>latitude</code>：十进制度数表示的纬度</li><li><code>longitude</code>：十进制度数表示的经度</li><li><code>accuracy</code>：经纬度坐标的精度，以米为单位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(function (position) &#123;</span><br><span class="line">drawMapCenteredAt(position.coords.latitude, position.coords.longitude);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>失败回调</code>在被调用的时候也会接受到一个参数，这个参数是一个对象，包含连个属性：<code>message</code>和<code>code</code>。<code>code</code>保存着一个数值，表示错误的类型：用户拒绝共享（1）、位置无效（2）或者超时（3）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(function (position) &#123;</span><br><span class="line">drawMapCenteredAt(position.coords.latitude, position.coords.longitude);</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">console.log(&#39;Error code:&#39; + error.code);</span><br><span class="line">console.log(&#39;Error message:&#39; + error.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>第三个参数是一个<code>可选对象</code>，用于设定信息的类型。可以设置的选项有三个：</p><ul><li><code>enableHightAccuracy</code>：布尔值，表示必须尽可能使用最准确定的位置信息</li><li><code>timeout</code>：以毫秒数表示的等待位置信息的最长时间</li><li><code>maximumAge</code>：表示上一次取得的坐标信息的有效时间，以毫秒表示，如果时间到则重新取得新坐标信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">drawMapCenteredAt(position.coords.latitude, position.coords.longitude);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Error code:'</span> + error.code);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Error message:'</span> + error.message);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">enableHighAccuracy: <span class="literal">true</span>,</span><br><span class="line">timeout: <span class="number">5000</span>,</span><br><span class="line">maximumAge: <span class="number">25000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>File API 在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5在DOM中为文件输入元素添加了一个<code>files</code>集合。每个<strong>File</strong>对象都有下列只读属性。</p><ul><li><code>name</code>：本地文件系统的文件名</li><li><code>size</code>：文件的字节大小</li><li><code>type</code>：字符串，文件的MIME类型</li><li><code>lastModifiedDate</code>：字符串，文件上一次修改的时间</li></ul><h4 id="FileReader-类型"><a href="#FileReader-类型" class="headerlink" title="FileReader 类型"></a>FileReader 类型</h4><p>FileReader 类型实现的是一种异步文件读取机制。可以把<code>FileReader</code>想象成<code>XMLHttpRequest</code>。</p><ul><li><code>readAsText(file, encoding)</code>：以纯文本形式读取文件，将读取到的文本保存在<code>result</code>属性中，第二个参数用于指定编码类型（可选）</li><li><code>readAsDataURL(file)</code>：读取文件并将文件以数据URI形式保存在<code>result</code>属性中</li><li><code>readAsBinaryString(file)</code>：读取文件并将一个字符串保存在<code>result</code>属性中，字符串中的每个字符表示一字节</li><li><code>readAsArrayBuffer(file)</code>：读取文件并将一个包含文件内容的<code>ArrayBuffer</code>保存在<code>result</code>属性中</li></ul><p>由于读取过程是异步的，所以<code>FileReader</code>提供了三个事件：</p><ul><li><code>progress</code></li><li><code>error</code></li><li><code>load</code></li></ul><p><code>progress</code>事件，每50ms就会触发一次，通过事件对象可以获得与<code>XHR</code>的<code>progress</code>事件相同的信息：</p><ul><li><code>lengthComputable</code></li><li><code>loaded</code></li><li><code>total</code></li></ul><p>由于种种原因无法读取文件，都会触发<code>error</code>事件，相关信息都会保存到<code>FileReader</code>的<code>error</code>属性中。<code>error.code</code>即错误码：</p><ul><li><code>1</code>：为找到文件</li><li><code>2</code>：安全性错误</li><li><code>3</code>：读取中断</li><li><code>4</code>：文件不可读</li><li><code>5</code>：编码错误</li></ul><p>文件加载成功后会触发<code>load</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filesList = <span class="built_in">document</span>.getElementById(<span class="string">'files-list'</span>);</span><br><span class="line">EventUtil.addHandler(filesList, <span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> info = <span class="string">''</span>,</span><br><span class="line">output = <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>),</span><br><span class="line">progress = <span class="built_in">document</span>.getElementById(<span class="string">'progress'</span>),</span><br><span class="line">files = EventUtil.getTarget(event).files,</span><br><span class="line">type = <span class="string">'default'</span>,</span><br><span class="line">reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/image/</span>.test(files[<span class="number">0</span>].type)) &#123;</span><br><span class="line">reader.readAsDateURL(files[<span class="number">0</span>]);</span><br><span class="line">type = <span class="string">'image'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reader.readAsText(files[<span class="number">0</span>]);</span><br><span class="line">type = <span class="string">'text'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">output.innerHTML = <span class="string">'Could not read file, error code is '</span> + reader.error.code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reader.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">progress.innerHTML = event.loaded + <span class="string">'/'</span> + event.total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'image'</span>:</span><br><span class="line">html = <span class="string">'&lt;img src=\"'</span> + reader.result + <span class="string">'\"&gt;'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'text'</span>:</span><br><span class="line">html = reader.result;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">output.innerHTML = html;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="读取拖放的文件"><a href="#读取拖放的文件" class="headerlink" title="读取拖放的文件"></a>读取拖放的文件</h4><p>从桌面上把文件拖放到浏览器中会触发<code>drop</code> 事件。而且可以在<code>event.dataTransfer. files</code>中读取到被放置的文件，当然此时它是一个<code>File</code> 对象，与通过文件输入字段取得的<code>File</code> 对象一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">'droptarget'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> info = <span class="string">''</span>,</span><br><span class="line">output = <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>);</span><br><span class="line">files, i, len;</span><br><span class="line">EventUtil.preventDefault(event);</span><br><span class="line"><span class="keyword">if</span> (event.type == <span class="string">'drop'</span>) &#123;</span><br><span class="line">files = event.dataTransfer.files;  <span class="comment">//转换成File对象</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">len = files.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">info += files[i].name + <span class="string">' ('</span> + files[i].type + <span class="string">', '</span> + files[i].size + <span class="string">' bytes)&lt;br&gt;'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">output.innerHTML = info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 阻止默认事件，只有 drop 事件会被处理</span></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"drop"</span>, handleEvent);</span><br></pre></td></tr></table></figure></p><h4 id="使用XHR上传文件"><a href="#使用XHR上传文件" class="headerlink" title="使用XHR上传文件"></a>使用XHR上传文件</h4><p>创建一个<code>FormDate</code>对象，通过它调用<code>append()</code>方法并传入相应的<code>File</code>对象作为参数，再把<code>FormData</code>对象传递给<code>XHR</code>的<code>send()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">'droptarget'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> info = <span class="string">''</span>,</span><br><span class="line">output = <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>),</span><br><span class="line">data, xhr,</span><br><span class="line">files, i, len;</span><br><span class="line"></span><br><span class="line">EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event.type == <span class="string">'drop'</span>) &#123;</span><br><span class="line">data = <span class="keyword">new</span> FormData();</span><br><span class="line">files = event.dataTransfer.files;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">len = files.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">data.append(<span class="string">'file'</span> + i, files[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'FileAPIExapleUpload.php'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"drop"</span>, handleEvent);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了半个多月的时间，终于又把“JS红宝书”又撸了一遍。&lt;/p&gt;
&lt;p&gt;第一次读“JS红宝书”还是&lt;strong&gt;2015&lt;/strong&gt;年初学JS的时候，那时候只是把语法部分读了一遍，还有一些浏览器相关知识做了下了解，大概也就读了半本的样子，&lt;br&gt;就开始了用JS进行开发了，在成长的道路上遇见了&lt;strong&gt;JQuery&lt;/strong&gt;，当时真的是感觉到&lt;strong&gt;JQuery&lt;/strong&gt;太友好了，慢慢放下了原生开发。&lt;/p&gt;
&lt;p&gt;现在呢，更多的时候是在用框架进行开发，越来越觉得自己的JS基础很缺乏，然后就开启了“JS红宝书”二刷之路。&lt;/p&gt;
&lt;p&gt;下面就把书中自己觉得重要的、没有掌握的知识整理出来。因为我觉得还是会三刷“JS红宝书”，希望把这本700多页的书越读越薄，勉励。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>读 《深入理解javascript原型和闭包》总结（三）</title>
    <link href="http://yoursite.com/2018/04/06/%E8%AF%BB-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/06/读-《深入理解javascript原型和闭包》总结（三）/</id>
    <published>2018-04-06T02:58:44.000Z</published>
    <updated>2019-11-27T08:11:17.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个</p><p><strong><em>其实这是一个压栈出栈的过程——执行上下文栈</em></strong></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/232122300768665.png?raw=true" alt=""></p><p>有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。<br>要说闭包，咱们还得先从自由变量和作用域说起。</p><a id="more"></a><h3 id="简介【作用域】"><a href="#简介【作用域】" class="headerlink" title="简介【作用域】"></a>简介【作用域】</h3><p>“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。</p><p><strong><em>javascript除了全局作用域之外，只有函数可以创建的作用域。</em></strong></p><p><strong><em>我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</em></strong></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/241708372951952.png?raw=true" alt=""></p><p>全局代码和fn、bar两个函数都会形成一个作用域。而且，<strong><em>作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</em></strong>。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级</p><p><strong><em>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</em></strong></p><h3 id="【作用域】和【上下文环境】"><a href="#【作用域】和【上下文环境】" class="headerlink" title="【作用域】和【上下文环境】"></a>【作用域】和【上下文环境】</h3><p>除了全局作用域之外，每个函数都会创建自己的作用域，<strong><em>作用域在函数定义时就已经确定了。而不是在函数调用时确定。</em></strong></p><p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250814158269779.png?raw=true" alt=""></p><p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250814386853995.png?raw=true" alt=""></p><p>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250815006238997.png?raw=true" alt=""></p><p>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250815248579200.png?raw=true" alt=""></p><p>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250815435609914.png?raw=true" alt=""></p><p>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250816112012394.png?raw=true" alt=""></p><p>最后我们可以把以上这几个图片连接起来看看。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250816269984619.png?raw=true" alt=""></p><p><strong><em>作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</em></strong>。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，<strong><em>作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</em></strong>。</p><p><strong><em>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</em></strong></p><h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><p>自由变量： 在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x + b); <span class="comment">// 这里的 X 就是一个自由变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn();   <span class="comment">// 10 , 而不是 20</span></span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(fn);</span><br></pre></td></tr></table></figure><p><strong><em>自由变量要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</em></strong> — 这就是所谓的“静态作用域”</p><p>作用域的过程</p><p>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</p><p>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</p><p>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；<br>第四步，跳转到第一步。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong><em>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。</em></strong></p><p><strong><em>你只需要知道闭包应用的两种情况即可——函数作为返回值，函数作为参数传递</em></strong></p><p>第一，函数作为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = fn()</span><br><span class="line"></span><br><span class="line">f1(<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>第二，函数作为参数被传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>,</span><br><span class="line">    fn = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x &gt; max) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">100</span>;</span><br><span class="line">  f(<span class="number">15</span>);</span><br><span class="line">&#125;)(fn);</span><br></pre></td></tr></table></figure><p>函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p><p>演示例子：</p><p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260749349988764.png?raw=true" alt=""></p><p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260750319351092.png?raw=true" alt=""></p><p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p><p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p><p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260957500455644.png?raw=true" alt=""></p><p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260958057327369.png?raw=true" alt=""></p><p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p><p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p><p>第五步，执行完20行就是上下文环境的销毁过程</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;执行上下文栈&quot;&gt;&lt;a href=&quot;#执行上下文栈&quot; class=&quot;headerlink&quot; title=&quot;执行上下文栈&quot;&gt;&lt;/a&gt;执行上下文栈&lt;/h3&gt;&lt;p&gt;执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;其实这是一个压栈出栈的过程——执行上下文栈&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/232122300768665.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。&lt;br&gt;要说闭包，咱们还得先从自由变量和作用域说起。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>读 《深入理解javascript原型和闭包》总结（二）</title>
    <link href="http://yoursite.com/2018/04/06/%E8%AF%BB-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/06/读-《深入理解javascript原型和闭包》总结（二）/</id>
    <published>2018-04-06T01:43:11.000Z</published>
    <updated>2019-11-27T08:11:17.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>JavaScript 中的继承是通过原型链来体现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">f1.a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Foo.prototype.a = <span class="number">100</span>;</span><br><span class="line">Foo.prototype.b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1.a); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.b); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><p>f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为<code>f1.__proto__</code>指向的是<code>Foo.prototype</code></p><p><strong><em>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是原型链</em></strong></p><p><strong><em>如何区分一个属性到底是基本的还是从原型中找到的 —- hasOwnProperty</em></strong></p><p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p><p>每个函数都有call，apply方法，都有length，arguments，caller等属性。函数由Function函数创建，因此继承的Function.prototype中的方法。Function.prototype继承自Object.prototype的方法，<code>Function.prototype.__proto__</code>指向Object.prototype</p><p>JavaScript对象属性是可以随时改动的，如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><a id="more"></a><h3 id="执行上下文（一）"><a href="#执行上下文（一）" class="headerlink" title="执行上下文（一）"></a>执行上下文（一）</h3><p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的，</p><p>第一种情况<br><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221744084828533.png?raw=true" alt="验证"></p><p>第二种情况<br><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221744319354566.png?raw=true" alt=""></p><p>第三种情况，<br><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221745066078791.png?raw=true" alt=""></p><p>第一种情况：只是对变量进行声明（并没有赋值）。</p><p>第二种情况：直接给this赋值。这也是“准备工作”情况要做的事情之一</p><p>第三种情况：需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。</p><p>在准备工作中完成了哪些任务（<strong><em>重点</em></strong>）</p><hr><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值</li></ul><hr><p><strong><em>这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</em></strong></p><p>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。<strong><em>这个“代码段”其实分三种情况——全局代码，函数体，eval代码。</em></strong></p><p>所谓“代码段”就是一段文本形式的代码</p><ol><li>全局代码是一种</li><li>eval代码接受的也是一段文本形式的代码</li><li>函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。</li></ol><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221746370927602.png?raw=true" alt=""></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221747371078703.png?raw=true" alt=""></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221746583578531.png?raw=true" alt=""></p><h3 id="执行上下文（下）"><a href="#执行上下文（下）" class="headerlink" title="执行上下文（下）"></a>执行上下文（下）</h3><p>执行上下文环境中有如何数据：</p><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值；</li></ul><p>如果在函数中，除了上面的数据之外，还会有其他数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，<strong><em>函数每被调用一次，都会产生一个新的执行上下文环境。</em></strong> 因为不同的调用可能就会有不同的参数。</p><p>另外一点不同在于，<strong><em>函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</em></strong></p><p>总结：全局代码的上下文环境数据内容为：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>普通变量（包括函数表达式），如:var a=10;</td><td>声明(默认赋值为undefined)</td></tr><tr><td>函数声明,如:function fn(){}</td><td>赋值</td></tr><tr><td>this</td><td>赋值</td></tr></tbody></table><p>如果代码段是函数体，在此基础上需要附加：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>参数</td><td>赋值</td></tr><tr><td>arguments</td><td>赋值</td></tr><tr><td>自由变量的取值作用域</td><td>赋值</td></tr></tbody></table><p>给执行上下文环境下一个通俗的定义——<strong><em>在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</em></strong></p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><strong><em>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</em></strong><br>因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p><h6 id="情况1：-构造函数"><a href="#情况1：-构造函数" class="headerlink" title="情况1： 构造函数"></a>情况1： 构造函数</h6><p>构造函数就是用new对象的函数。所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xxx'</span>;</span><br><span class="line">  <span class="keyword">this</span>.year = <span class="number">1991</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f1.name);</span><br><span class="line"><span class="built_in">console</span>.log(f1.year);</span><br></pre></td></tr></table></figure><p>以上代码可以看出，<strong><em>如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象</em></strong></p><p>注意： 上面的情况仅限 new Foo() 的情况，即Foo函数作为构造函数的情况。</p><h6 id="情况2：函数作为对象的一个属性"><a href="#情况2：函数作为对象的一个属性" class="headerlink" title="情况2：函数作为对象的一个属性"></a>情况2：函数作为对象的一个属性</h6><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure><p>以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象</p><h6 id="情况3：函数用call或者apply调用"><a href="#情况3：函数用call或者apply调用" class="headerlink" title="情况3：函数用call或者apply调用"></a>情况3：函数用call或者apply调用</h6><p>当一个函数被call和apply调用时，this的值就取传入的对象的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">// Object &#123;x: 10&#125;  10</span></span><br></pre></td></tr></table></figure><h6 id="情况4：全局-amp-调用普通函数"><a href="#情况4：全局-amp-调用普通函数" class="headerlink" title="情况4：全局 &amp; 调用普通函数"></a>情况4：全局 &amp; 调用普通函数</h6><p>在全局环境下，this永远是window，这个应该没有非议。</p><p>普通函数在调用时，其中的this也都是window</p><p>下面的情况需要注意下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">    f()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure></p><p>函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window</p><h6 id="补充-—-在构造函数的prototype中，this代表着什么。"><a href="#补充-—-在构造函数的prototype中，this代表着什么。" class="headerlink" title="补充 — 在构造函数的prototype中，this代表着什么。"></a>补充 — 在构造函数的prototype中，this代表着什么。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'xxx'</span></span><br><span class="line">  <span class="keyword">this</span>.year = <span class="number">1991</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn()</span><br><span class="line">f1.getName();</span><br></pre></td></tr></table></figure><p>如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。</p><p><strong><em>其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;JavaScript 中的继承是通过原型链来体现的。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f1.a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Foo.prototype.a = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Foo.prototype.b = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.a); &lt;span class=&quot;comment&quot;&gt;//10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.b); &lt;span class=&quot;comment&quot;&gt;// 200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为&lt;code&gt;f1.__proto__&lt;/code&gt;指向的是&lt;code&gt;Foo.prototype&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着&lt;code&gt;__proto__&lt;/code&gt;这条链向上找，这就是原型链&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;如何区分一个属性到底是基本的还是从原型中找到的 —- hasOwnProperty&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。&lt;/p&gt;
&lt;p&gt;每个函数都有call，apply方法，都有length，arguments，caller等属性。函数由Function函数创建，因此继承的Function.prototype中的方法。Function.prototype继承自Object.prototype的方法，&lt;code&gt;Function.prototype.__proto__&lt;/code&gt;指向Object.prototype&lt;/p&gt;
&lt;p&gt;JavaScript对象属性是可以随时改动的，如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>读 《深入理解javascript原型和闭包》总结（一）</title>
    <link href="http://yoursite.com/2018/01/10/%E8%AF%BB%20%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/10/读 《深入理解javascript原型和闭包》总结（一）/</id>
    <published>2018-01-10T09:52:32.000Z</published>
    <updated>2019-11-27T08:11:17.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);    <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);   <span class="comment">// number</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'abc'</span>); <span class="comment">// string</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);  <span class="comment">// boolean</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);  <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">true</span>]);  <span class="comment">//object</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);  <span class="comment">//object</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);  <span class="comment">//object</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>));  <span class="comment">//object</span></span><br><span class="line">&#125;</span><br><span class="line">show();</span><br></pre></td></tr></table></figure><p>（undefined, number, string, boolean）属于简单的值类型，不是对象。（函数、数组、对象、null、new Number(10)、）属于引用类型，都是对象。（引用类型都是对象）</p><p><strong><em> 判断一个变量是不是对象非常简单。值类型的类型判断用<code>typeof</code>，引用类型的类型判断用<code>instanceof</code>。  </em></strong></p><p>java中的对象是通过<code>new</code>一个<code>class</code>创建的。对于属性、方法、字段都是非常严格的。但是<code>javascript</code>的对象比较随意–数组是对象，函数式对象，对象还是对象。对象里面的一切都是属性（ <strong><em> 方法也是一种属性 </em></strong> ），属性表示为键值对的形式。<strong><em> 对象是属性的集合 </em></strong></p><p>JavaScript中的对象可以任意的扩展属性，没有<code>class</code>的约束。</p><a id="more"></a><hr><h3 id="函数和对象的关系"><a href="#函数和对象的关系" class="headerlink" title="函数和对象的关系"></a>函数和对象的关系</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><p>函数是一种对象，你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。函数和对象关系比较复杂。</p><p>通过下面的内容缕一缕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'王福朋'</span>;</span><br><span class="line">    <span class="keyword">this</span>.year = <span class="number">1988</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="built_in">Object</span>)); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="built_in">Array</span>)); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p>通过上述代码，可以得出：<code>对象都是通过函数来创建</code>。</p><h3 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a>prototype 原型</h3><p><strong><em> 每个函数都有一个属性叫做prototype </em></strong> 。这个prototype的属性值是一个对象（<strong><em>属性的集合，再次强调</em></strong>），默认的只有一个叫做<code>constructor</code>的属性，指向这个函数本身。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/172121182841896.png?raw=true" alt="prototype"></p><p>Object</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/172130097842386.png?raw=true" alt="Object"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">   Fn.prototype.name = <span class="string">'王福朋'</span>;</span><br><span class="line">   Fn.prototype.getYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1988</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> fn = <span class="keyword">new</span> Fn();</span><br><span class="line">   <span class="built_in">console</span>.log(fn.name);</span><br><span class="line">   <span class="built_in">console</span>.log(fn.getYear());</span><br></pre></td></tr></table></figure><p>Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p><h3 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h3><p>每个对象都有一个隐藏的属性——<code>__proto__</code>，这个属性引用了创建这个对象的函数的prototype。即：<code>fn.__proto__ === Fn.prototype</code>。这里的<code>__proto__</code>成为“隐式原型”</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181509180812624.png?raw=true" alt="__proto__"></p><blockquote><p>总结：每个函数function都有一个prototype，即原型。每个对象都有一个<code>__proto__</code>，可成为隐式原型。特殊：Object.prototype是一个特例——它的<strong>proto</strong>指向的是null，切记切记</p></blockquote><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181510403153733.png?raw=true" alt="Object.prototype"></p><p>谁创建了函数？看下面的内容</p><p>函数也是对象，它也有<code>__proto__</code>。函数是被 Function 创建出来的。 —- 这里的 “F” 是大写</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181511124714709.png?raw=true" alt="Function"></p><p>以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。</p><p>总结：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181512068463597.png?raw=true" alt="总结"></p><blockquote><p>注意点：<code>Object.__proto__</code>指向<code>Function.prototype</code>，<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>指向 <code>Object.prototype</code>。因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。</p></blockquote><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><strong><em> instanceof判断规则 </em></strong></p><p>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p><p>Instanceof的判断队则是：<strong><em>沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</em></strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.console.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br></pre></td></tr></table></figure><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181637013624694.png?raw=true" alt="instanceof"></p><p>instanceof表示的就是一种继承关系，或者原型链的结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一切都是对象&quot;&gt;&lt;a href=&quot;#一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;一切都是对象&quot;&gt;&lt;/a&gt;一切都是对象&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; x);    &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;// number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// boolean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;);  &lt;span class=&quot;comment&quot;&gt;//function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;]);  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &amp;#125;);  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（undefined, number, string, boolean）属于简单的值类型，不是对象。（函数、数组、对象、null、new Number(10)、）属于引用类型，都是对象。（引用类型都是对象）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt; 判断一个变量是不是对象非常简单。值类型的类型判断用&lt;code&gt;typeof&lt;/code&gt;，引用类型的类型判断用&lt;code&gt;instanceof&lt;/code&gt;。  &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java中的对象是通过&lt;code&gt;new&lt;/code&gt;一个&lt;code&gt;class&lt;/code&gt;创建的。对于属性、方法、字段都是非常严格的。但是&lt;code&gt;javascript&lt;/code&gt;的对象比较随意–数组是对象，函数式对象，对象还是对象。对象里面的一切都是属性（ &lt;strong&gt;&lt;em&gt; 方法也是一种属性 &lt;/em&gt;&lt;/strong&gt; ），属性表示为键值对的形式。&lt;strong&gt;&lt;em&gt; 对象是属性的集合 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript中的对象可以任意的扩展属性，没有&lt;code&gt;class&lt;/code&gt;的约束。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2017/10/25/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2017/10/25/跨域/</id>
    <published>2017-10-25T13:06:03.000Z</published>
    <updated>2019-11-27T08:11:17.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript跨域总结与解决办法"><a href="#JavaScript跨域总结与解决办法" class="headerlink" title="JavaScript跨域总结与解决办法"></a>JavaScript跨域总结与解决办法</h1><ul><li>什么是跨域</li><li>document.domain+iframe的设置</li><li>动态创建script</li><li>利用iframe和location.hash</li><li>window.name实现的跨域数据传输</li><li>使用HTML5 postMessage</li><li>利用flash</li></ul><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名下</td><td>允许</td></tr><tr><td><a href="http://www.a.com/lab/a.js" target="_blank" rel="noopener">http://www.a.com/lab/a.js</a>  <a href="http://www.a.com/script/b.js" target="_blank" rel="noopener">http://www.a.com/script/b.js</a></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><a href="http://www.a.com:8000/a.js" target="_blank" rel="noopener">http://www.a.com:8000/a.js</a>    <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a>  <a href="https://www.a.com/b.js" target="_blank" rel="noopener">https://www.a.com/b.js</a></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> <a href="http://70.32.92.74/b.js" target="_blank" rel="noopener">http://70.32.92.74/b.js</a></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a>  <a href="http://script.a.com/b.js" target="_blank" rel="noopener">http://script.a.com/b.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a>  <a href="http://a.com/b.js" target="_blank" rel="noopener">http://a.com/b.js</a></td><td>同一域名，不同二级域名（同上）</td><td>不允许（cookie这种情况下也不允许访问）</td></tr><tr><td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="noopener">http://www.cnblogs.com/a.js</a>    <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><a id="more"></a><p>特别注意两点：<br>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，<br>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</p><p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match</p><h5 id="1-document-domain-iframe的设置"><a href="#1-document-domain-iframe的设置" class="headerlink" title="1. document.domain+iframe的设置"></a>1. document.domain+iframe的设置</h5><p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决</p><p>www.a.com上的a.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br><span class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'http://script.a.com/b.html'</span>;</span><br><span class="line">ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    <span class="comment">// 在这里操纵b.html</span></span><br><span class="line">    alert(doc.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>script.a.com上的b.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br></pre></td></tr></table></figure><p>问题：<br>1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。<br>2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</p><h5 id="2-动态创建script"><a href="#2-动态创建script" class="headerlink" title="2. 动态创建script"></a>2. 动态创建script</h5><p>这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">js.onload = js.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.readyState || <span class="keyword">this</span>.readyState === <span class="string">'loaded'</span> || <span class="keyword">this</span>.readyState === <span class="string">'complete'</span>) &#123;</span><br><span class="line">        <span class="comment">// callback在此处执行</span></span><br><span class="line">        js.onload = js.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-利用iframe和location-hash"><a href="#3-利用iframe和location-hash" class="headerlink" title="3. 利用iframe和location.hash"></a>3. 利用iframe和location.hash</h5><p>原理是利用location.hash来进行传值。在url： <a href="http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。" target="_blank" rel="noopener">http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。</a></p><p>假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。</p><p>先是a.com下的文件cs1.html文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startRequest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line">    ifr.src = <span class="string">'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = location.hash ? location.hash.substring(<span class="number">1</span>) : <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">console</span>.log) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Now the data is '</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(checkHash, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>cnblogs.com域名下的cs2.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一个简单的参数处理操作</span></span><br><span class="line"><span class="keyword">switch</span>(location.hash)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramdo'</span>:</span><br><span class="line">        callBack();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramset'</span>:</span><br><span class="line">        <span class="comment">//do something……</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callBack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parent.location.hash = <span class="string">'somedata'</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，</span></span><br><span class="line">        <span class="comment">// 所以要利用一个中间的cnblogs域下的代理iframe</span></span><br><span class="line">        <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">        ifrproxy.style.display = <span class="string">'none'</span>;</span><br><span class="line">        ifrproxy.src = <span class="string">'http://a.com/test/cscript/cs3.html#somedata'</span>;    <span class="comment">// 注意该文件在"a.com"域下</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(ifrproxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a.com下的域名cs3.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span></span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……</p><h5 id="4-window-name实现的跨域数据传输"><a href="#4-window-name实现的跨域数据传输" class="headerlink" title="4. window.name实现的跨域数据传输"></a>4. window.name实现的跨域数据传输</h5><p>有三个页面：</p><p>a.com/app.html：应用页面。<br>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。<br>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</p><ol><li>在应用页面（a.com/app.html）中创建一个iframe，把其src指向数据页面（b.com/data.html）。<br>数据页面会把数据附加到这个iframe的window.name上</li></ol><p>data.html 代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">window</span>.name = <span class="string">'I was there!'</span>;    <span class="comment">// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右</span></span><br><span class="line">    <span class="comment">//// 数据格式可以自定义，如json、字符串</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>在应用页面（a.com/app.html）中监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。</p><p>app.html部分代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>, </span><br><span class="line">    iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>),</span><br><span class="line">    loadfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> data = iframe.contentWindow.name;    <span class="comment">// 读取数据</span></span><br><span class="line">            alert(data);    <span class="comment">//弹出'I was there!'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">            iframe.contentWindow.location = <span class="string">"http://a.com/proxy.html"</span>;    <span class="comment">// 设置的代理文件</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    iframe.src = <span class="string">'http://b.com/data.html'</span>;</span><br><span class="line">    <span class="keyword">if</span> (iframe.attachEvent) &#123;</span><br><span class="line">        iframe.attachEvent(<span class="string">'onload'</span>, loadfn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iframe.onload  = loadfn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">    iframe.contentWindow.close();</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h5 id="5-使用HTML5-postMessage"><a href="#5-使用HTML5-postMessage" class="headerlink" title="5. 使用HTML5 postMessage"></a>5. 使用HTML5 postMessage</h5><p>Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+  支持这个API</p><p>otherWindow.postMessage(message, targetOrigin);<br>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message: 所要发送的数据，string类型。<br>targetOrigin: 用于限制otherWindow，“*”表示不作限制</p><p>a.com/index.html中的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"ifr"</span> src=<span class="string">"b.com/index.html"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">window.onload = function() &#123;</span></span><br><span class="line"><span class="string">    var ifr = document.getElementById('ifr');</span></span><br><span class="line"><span class="string">    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样</span></span><br><span class="line"><span class="string">                                        // 若写成'http://c.com'就不会执行postMessage了</span></span><br><span class="line"><span class="string">    ifr.contentWindow.postMessage('I was there!', targetOrigin);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>b.com/index.html中的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 通过origin属性判断消息来源地址</span></span><br><span class="line">        <span class="keyword">if</span> (event.origin == <span class="string">'http://a.com'</span>) &#123;</span><br><span class="line">            alert(event.data);    <span class="comment">// 弹出"I was there!"</span></span><br><span class="line">            alert(event.source);  <span class="comment">// 对a.com、index.html中window对象的引用</span></span><br><span class="line">             <span class="comment">// 但由于同源策略，这里event.source不可以访问window对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript跨域总结与解决办法&quot;&gt;&lt;a href=&quot;#JavaScript跨域总结与解决办法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript跨域总结与解决办法&quot;&gt;&lt;/a&gt;JavaScript跨域总结与解决办法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是跨域&lt;/li&gt;
&lt;li&gt;document.domain+iframe的设置&lt;/li&gt;
&lt;li&gt;动态创建script&lt;/li&gt;
&lt;li&gt;利用iframe和location.hash&lt;/li&gt;
&lt;li&gt;window.name实现的跨域数据传输&lt;/li&gt;
&lt;li&gt;使用HTML5 postMessage&lt;/li&gt;
&lt;li&gt;利用flash&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h3&gt;&lt;p&gt;JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;URL&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;是否允许通信&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/a.js&lt;/a&gt; &lt;a href=&quot;http://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名下&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/lab/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/lab/a.js&lt;/a&gt;  &lt;a href=&quot;http://www.a.com/script/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/script/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名下不同文件夹&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com:8000/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com:8000/a.js&lt;/a&gt;    &lt;a href=&quot;http://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名，不同端口&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/a.js&lt;/a&gt;  &lt;a href=&quot;https://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名，不同协议&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/a.js&lt;/a&gt; &lt;a href=&quot;http://70.32.92.74/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://70.32.92.74/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;域名和域名对应ip&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/a.js&lt;/a&gt;  &lt;a href=&quot;http://script.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://script.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;主域相同，子域不同&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/a.js&lt;/a&gt;  &lt;a href=&quot;http://a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名，不同二级域名（同上）&lt;/td&gt;
&lt;td&gt;不允许（cookie这种情况下也不允许访问）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/a.js&lt;/a&gt;    &lt;a href=&quot;http://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;不同域名&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript类数组(ArrayLike)转化成数组</title>
    <link href="http://yoursite.com/2017/10/18/javascript%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/10/18/javascript类数组转化成数组/</id>
    <published>2017-10-18T13:58:27.000Z</published>
    <updated>2019-11-27T08:11:17.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript类数组转化成数组"><a href="#javascript类数组转化成数组" class="headerlink" title="javascript类数组转化成数组"></a>javascript类数组转化成数组</h1><h2 id="什么是类数组（ArrayLike）？"><a href="#什么是类数组（ArrayLike）？" class="headerlink" title="什么是类数组（ArrayLike）？"></a>什么是类数组（ArrayLike）？</h2><p>ArrayLike（类数组/伪数组）即拥有数组的一部分行为,例如 arguments, NodeList等！他们拥有<strong><em>length</em></strong>属性，但是却不能用一些数组的方法，如 push，pop等等</p><p>常见的ArrayLike有下面的这几个：</p><ul><li>Arguments</li><li>NodeList</li><li>StyleSheetList</li><li>HTMLCollection</li><li>HTMLFormControlsCollection (继承HTMLCollection)</li><li>HTMLOptionsCollection(继承HTMLCollection)</li><li>HTMLAllCollection</li><li>DOMTokenList</li></ul><a id="more"></a><h2 id="Array-Like-to-Array"><a href="#Array-Like-to-Array" class="headerlink" title="Array-Like to Array"></a>Array-Like to Array</h2><p>在项目开发中，经常遇到需要把 Array-Like Objects 转为 Array 类型，使之能用数组的一些方法。下面列出几种方法：</p><ul><li>for循环</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++)</span><br><span class="line">  arr[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>Array.prototype.slice.call(array-like object)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>或者可以用 <strong><em>[]</em></strong> 代替 Array.prototype</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>原理： slice的内部实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//slice的内部实现</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span>(<span class="params">start,end</span>)</span>&#123;  </span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();  </span><br><span class="line">      start = start || <span class="number">0</span>;  </span><br><span class="line">      end = end || <span class="keyword">this</span>.length; <span class="comment">//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键  </span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = start; i &lt; end; i++)&#123;  </span><br><span class="line">           result.push(<span class="keyword">this</span>[i]);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> result;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>兼容 IE8 以下的浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toArray = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(s);  </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;  </span><br><span class="line">            <span class="keyword">var</span> arr = [];  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = s.length; i &lt; len; i++)&#123;  </span><br><span class="line">                <span class="comment">//arr.push(s[i]);  </span></span><br><span class="line">                 arr[i] = s[i];     <span class="comment">//据说这样比push快</span></span><br><span class="line">            &#125;  </span><br><span class="line">             <span class="keyword">return</span> arr;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Array.from()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(str);</span><br></pre></td></tr></table></figure><h3 id="Array-Like-to-Array-注意点"><a href="#Array-Like-to-Array-注意点" class="headerlink" title="Array-Like to Array 注意点"></a>Array-Like to Array 注意点</h3><p>arguments 转换成数组的时候经常会把 <strong><em>Array.prototype.slice.call(arguments)</em></strong> 用更短的写法 <strong><em> [].slice.call(arguments)</em></strong></p><p>这个将导致Chrome和Node中使用的V8引擎跳过对其的优化，使其性能相当慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript类数组转化成数组&quot;&gt;&lt;a href=&quot;#javascript类数组转化成数组&quot; class=&quot;headerlink&quot; title=&quot;javascript类数组转化成数组&quot;&gt;&lt;/a&gt;javascript类数组转化成数组&lt;/h1&gt;&lt;h2 id=&quot;什么是类数组（ArrayLike）？&quot;&gt;&lt;a href=&quot;#什么是类数组（ArrayLike）？&quot; class=&quot;headerlink&quot; title=&quot;什么是类数组（ArrayLike）？&quot;&gt;&lt;/a&gt;什么是类数组（ArrayLike）？&lt;/h2&gt;&lt;p&gt;ArrayLike（类数组/伪数组）即拥有数组的一部分行为,例如 arguments, NodeList等！他们拥有&lt;strong&gt;&lt;em&gt;length&lt;/em&gt;&lt;/strong&gt;属性，但是却不能用一些数组的方法，如 push，pop等等&lt;/p&gt;
&lt;p&gt;常见的ArrayLike有下面的这几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arguments&lt;/li&gt;
&lt;li&gt;NodeList&lt;/li&gt;
&lt;li&gt;StyleSheetList&lt;/li&gt;
&lt;li&gt;HTMLCollection&lt;/li&gt;
&lt;li&gt;HTMLFormControlsCollection (继承HTMLCollection)&lt;/li&gt;
&lt;li&gt;HTMLOptionsCollection(继承HTMLCollection)&lt;/li&gt;
&lt;li&gt;HTMLAllCollection&lt;/li&gt;
&lt;li&gt;DOMTokenList&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
